:reproducible:

= Control Flow Instructions

[#jmp-cap]
== Jump to Capabilities

The CJALR and CBNZ instructions allow jumping to a capability,
i.e., setting the program counter to a given capability,
in a unconditional or conditional manner.

.CJALR instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0100010' }
]}
....

.CBNZ instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0100011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* _{isa_var_pure}_
** `x[rs1]` is not a capability.
** `x[rs1].type` is neither `0` (linear) nor `1` (non-linear).
** `x[rs1].perms` is neither `5` (read-execute) nor `7` (read-write-execute).
* _{isa_var_hybrid}_
** `cwrld` is `0` (normal world).
** Any of the conditions for _{isa_var_pure}_ are met.

*If no exception is raised:*

* CJAL: Set the program counter (`pc`) to `x[rs1]`. Meanwhile, the existing
capability in `pc`, with its `cursor` field replaced by the address of the next instruction,
is written to the register `rd`.
* CBNZ: If `x[rs2]` is zero (`0`), the behaviour is the same as for NOP.
Otherwise, set the program counter (`pc`) to `x[rs1]`.

[#domain-cross]
== Domain Crossing

_Domains_ in {isa_name} are individual software compartments that
are protected by a safe context switching mechanism, i.e., domain crossing.
The mechanism is provided by the CALL and RETURN instructions.

=== CALL

The CALL instruction is used to call a sealed capability, i.e., to switch to another _domain_.

.CALL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0100000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* _{isa_var_pure}_
** `x[rs1]` is not a capability.
** `x[rs1].valid` is `0` (invalid).
** `x[rs1].type` is not `4` (sealed).
** `x[rs1].async` is not `0` (synchronous).
* _{isa_var_hybrid}_
** `cwrld` is `0` (normal world).
** Any of the conditions for _{isa_var_pure}_ are met.

*If no exception is raised:*

. Load the content at the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` to `ceh`.
. Load the content at the memory location `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)` to `deh`.
. Store the former `pc`, `ceh` and `deh` values to the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)`,
`[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` and `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)`
respectively.
. Set `x[rs1].type` to `5` (sealed-return), `x[rs1].reg` to `rd`, set `x[rs1].async` to `0` (synchronous),
and write the resulting `x[rs1]` to the register `cra`.

=== RETURN

.RETURN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0100001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* _{isa_var_pure}_
** `x[rs1]` is not a capability.
** `x[rs1].valid` is `0` (invalid).
** `x[rs1].type` is not `5` (sealed-return).
** `x[rs2]` is not an integer.
* _{isa_var_hybrid}_
** `cwrld` is `0` (normal world).
** Any of the conditions for _{isa_var_pure}_ are met.

*If no exception is raised:*

*When `x[rs1].async = 0` (synchronous):*

. Load the content at the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` to  `ceh`.
. Load the content at the memory location `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)` to `deh`.
. Store the former `pc`, `ceh` and `deh` values to the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)`,
`[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` and `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)`
respectively.
. Set `x[rs1].type` to `4` (sealed), and write the
capability to the register `x[x[rs1].reg]`.

*When `x[rs1].async = 1` (upon exception) or `2` (upon interrupt):*

. Load the content at the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` to `ceh`.
. Load the content at the memory location `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)` to `deh`.
. For `i = 1, 2, ..., 31`, load the content at the memory location
`[x[rs1].base + (i + 2) * CLENBYTES, x[rs1].base + (i + 3) * CLENBYTES)`, to `x[i]` (the `i`-th general-purpose register).
. Write the former value of `pc`, with the `cursor` field replaced by `x[rs2]`, to
the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)`.
. Store the former alue of `ceh` to the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)`.
. Store the former value of `deh` to the memory location `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)`.
. Set the `x[rs1].type` to `4` (sealed). If `x[rs1].async = 1`, write the resulting `x[rs1]` to the register `ceh`. Otherwise (`x[rs1].async = 2`), write the resulting `x[rs1]` to the register `cih`.

.Note
****

When the `async` field of a sealed-return capability is `0` (synchronous), some
memory accesses are granted by this capability. The following table shows the
memory accesses granted by sealed and sealed-return capabilities in different scenarios.

.Memory accesses granted by sealed and sealed-return capabilities
[%header%autowidth.stretch]
|===
| Capability type | `async` | Read | Write | Execute
| Sealed | `0` | No | No | No
| Sealed | `1` | No | No | No
| Sealed-return | `0` | `cursor in [base, end)` | `cursor in [base, end)` | No
| Sealed-return | `1` | No | No | No
|===

****

[#world-switch]
== A World Switching Extension for _{isa_var_hybrid}_

In _{isa_var_hybrid}_, a pair of extra instructions, i.e., CAPENTER and CAPEXIT,
is added to support switching between the secure world and the normal world. 
The CAPENTER instruction causes an entry into the secure world from the
normal world, and the CAPEXIT instruction causes an exit from the secure
world into the normal world.

The CAPENTER instruction can only be used in the normal world, whereas
the CAPEXIT instruction can only be used in the secure world.
In addition, the CAPEXIT instruction can only be used when an exit capability
is provided.
Attempting to use those instructions in the wrong world or without the
required capability will cause an exception.
The behaviours of these 2 instructions 
roughly correspond to the CALL and RETURN instructions respectively.

=== CAPENTER

.CAPENTER instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0100100' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `cwrld` is `1` (secure world).
* `x[rs1]` is not a capability.
* `x[rs1].valid` is `0` (invalid).
* `x[rs1].type` is not `4` (sealed).

*If no exception is raised:*

*When `x[rs1].async = 0` (synchronous):*

. Load the content at the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` to `ceh`.
. Load the content at the memory location `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)` to `deh`.
. Store the former value of `pc` and `sp` to `normal_pc` and `normal_sp` respectively.
. Set `x[rs1].type` to `6` (exit), and write the resulting `x[rs1]` to `cra`.
. Write `rs1` to `switch_reg`.
. Write `rd` to `exit_reg`.
. Set `cwrld` to `1` (secure world).

*Otherwise:*

. Load the content at the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` to `ceh`.
. Load the content at the memory location `[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)` to `deh`.
. For `i = 1, 2, ..., 31`, load the content at the memory location
`[x[rs1].base + (i + 2) * CLENBYTES, x[rs1].base + (i + 3) * CLENBYTES)`, to `x[i]` (the `i`-th general-purpose register).
. Store the former value of `pc` and `sp` to `normal_pc` and `normal_sp` respectively.
. Set `x[rs1].type` to `5` (sealed-return), `x[rs1].async` to `0` (synchronous), and write the resulting `x[rs1]` to `switch_cap`.
. Write `rs1` to `switch_reg`.
. Write `rd` to `exit_reg`.
. Set `cwrld` to `1` (secure world).

.Note
****

The `rd` register will be set to a value indicating the cause of exit when
the CPU core exits from the secure world synchronously or asynchronously.

****

=== CAPEXIT

.CAPEXIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0100101' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `cwrld` is `0` (normal world).
* `x[rs1]` is not a capability.
* `x[rs1].valid` is `0` (invalid).
* `x[rs1].type` is not `6` (exit).
* `x[rs2]` is not an integer.

*If no exception is raised:*

. Write the content of `normal_pc` and `normal_sp` to `pc` and `sp` respectively.
. Write the former value of `pc`, with the `cursor` field replaced by `x[rs2]`,
to the memory location `[x[rs1].base, x[rs1].base + CLENBYTES)`.
. Write the former value of `ceh` and `csp` to the memory location
`[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` and
`[x[rs1].base + 2 * CLENBYTES, x[rs1].base + 3 * CLENBYTES)` respectively.
. Set `x[rs1].type` to `4` (sealed), `x[rs1].async`
to `0` (synchronous), and write the resulting `x[rs1]` to `x[switch_reg]`.
. Set `exit_reg` to `0` (normal exit).
. Set `cwrld` to `0` (normal world).
