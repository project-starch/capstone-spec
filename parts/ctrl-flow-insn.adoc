:reproducible:

= Control Flow Instructions

[#jmp-cap]
== Jump to Capabilities

The CJALR and CBNZ instructions allow jumping to a capability,
i.e., setting the program counter to a given capability,
in a unconditional or conditional manner.

.CJALR instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b101' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

_{isa_var_pure}_

* Unexpected operand type (24)
- `x[rs1]` is not a capability.

_{isa_var_hybrid}_

* Illegal instruction (2)
- `cwrld` is `0` (normal world).
* Unexpected operand type (24)
- `x[rs1]` is not a capability.

*If no exception is raised:*
Set `pc` to `x[rs1]`, and `pc.cursor` to `x[rs1].cursor + imm`.
Meanwhile, former `pc` (`pc.cursor` is the address of the former address of the next instruction) is written to `x[rd]`.
If `x[rs1]` is not a non-linear capability (i.e., `x[rs1].type != 1`), write `cnull` to `x[rs1]`.

.CBNZ instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b110' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

_{isa_var_pure}_

* Unexpected operand type (24)
- `x[rd]` is not a capability.
- `x[rs1]` is not an integer.

_{isa_var_hybrid}_

* Illegal instruction (2)
- `cwrld` is `0` (normal world).
* Unexpected operand type (24)
- `x[rd]` is not a capability.
- `x[rs1]` is not an integer.

*If no exception is raised:*

* If `x[rs1]` is `0`, the instruction is a no-op.
* Otherwise, set `pc` to `x[rd]`, and `pc.cursor` to `x[rd].cursor + imm`.
If `x[rd]` is not a non-linear capability (i.e., `x[rd].type != 1`), write `cnull` to `x[rd]`.

[#domain-cross]
== Domain Crossing

_Domains_ in {isa_name} are individual software compartments that
are protected by a safe context switching mechanism, i.e., _domain crossing_.
The mechanism is provided by the CALL and RETURN instructions.

=== CALL

The CALL instruction is used to call a sealed capability, i.e., to switch to another _domain_.

.CALL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (Z)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0100000' }
]}
....

*An exception is raised when any of the following conditions are met:*

_{isa_var_hybrid}_

* Illegal instruction (2)
- `cwrld` is `0` (normal world).

_{isa_var_pure}_ or _{isa_var_hybrid}_

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `4` (sealed).
- `x[rs1].async` is not `0` (synchronous).

*If no exception is raised:*

. `MOVC cra, rs1`.
. Swap the content at the memory location `[cra.base, cra.base + CLENBYTES)` with the program counter (`pc`).
. Swap the content at the memory location `[cra.base + CLENBYTES, cra.base + 2 * CLENBYTES)` with `ceh`.
. Swap the content at the memory location `[cra.base + 2 * CLENBYTES, cra.base + 3 * CLENBYTES)` with `csp`.
. Set `cra.type` to `5` (sealed-return), `cra.cursor` to `cra.base`, `cra.reg` to `rd`,
and `cra.async` to `0` (synchronous).

=== RETURN

.RETURN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0100001' }
]}
....

*An exception is raised when any of the following conditions are met:*

_{isa_var_hybrid}_

* Illegal instruction (2)
- `cwrld` is `0` (normal world).

_{isa_var_pure}_ or _{isa_var_hybrid}_

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not an integer.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `5` (sealed-return).

*If no exception is raised:*

*When `x[rs1].async = 0` (synchronous):*

. Write `x[rs1]` to `cap` and `cnull` to `x[rs1]`.
// Use swap here in case rs2 is the register sp
. Set `pc.cursor` to `x[rs2]`, and swap the content at the memory location
`[cap.base, cap.base + CLENBYTES)` with the program counter (`pc`).
. Swap the content at the memory location `[cap.base + CLENBYTES, cap.base + 2 * CLENBYTES)` with  `ceh`.
. Swap the content at the memory location `[cap.base + 2 * CLENBYTES, cap.base + 3 * CLENBYTES)` with `csp`.
. Write `cap` to `x[cap.reg]` and set `x[cap.reg].type` to `4` (sealed).

*When `x[rs1].async = 1` (upon exception):*

. Set `pc.cursor` to `x[rs2]`, and swap the content at the memory location
`[x[rs1].base, x[rs1].base + CLENBYTES)` with the program counter (`pc`).
// ceh is going to be overwritten, no need for a swap
. Store `ceh` to the memory location `[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)`.
. Set `x[rs1].type` to `4` (sealed), and write the resulting `x[rs1]` to `ceh`.
. For `i = 1, 2, ..., 31`, store `x[i]` to the memory location
`[ceh.base + (i + 1) * CLENBYTES, ceh.base + (i + 2) * CLENBYTES)`.

*When `x[rs1].async = 2` (upon interrupt):*

. Set `pc.cursor` to `x[rs2]`, and swap the content at the memory location
`[x[rs1].base, x[rs1].base + CLENBYTES)` with the program counter (`pc`).
. Swap the content at the memory location
`[x[rs1].base + CLENBYTES, x[rs1].base + 2 * CLENBYTES)` with `ceh`.
. Set `x[rs1].type` to `4` (sealed), and write the resulting `x[rs1]` to `cih`.
. For `i = 1, 2, ..., 31`, store `x[i]` to the memory location
`[cih.base + (i + 1) * CLENBYTES, cih.base + (i + 2) * CLENBYTES)`.

[#world-switch]
== A World Switching Extension for _{isa_var_hybrid}_

In _{isa_var_hybrid}_, a pair of extra instructions, i.e., CAPENTER and CAPEXIT,
is added to support switching between the _secure world_ and the _normal world_.

=== CAPENTER

The CAPENTER instruction causes an entry into the secure world from the normal world.
The instruction is only available in the normal world and is roughly equivalent to the CALL instruction.

.CAPENTER instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (Z)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0100010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Illegal instruction (0)
- `cwrld` is `1` (secure world).
* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `4` (sealed).

*If no exception is raised:*

*When `x[rs1].async = 0` (synchronous):*

. `MOVC cra, rs1`.
. Load the content at the memory location `[cra.base, cra.base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[cra.base + CLENBYTES, cra.base + 2 * CLENBYTES)` to `ceh`.
. Load the content at the memory location `[cra.base + 2 * CLENBYTES, cra.base + 3 * CLENBYTES)` to `csp`.
. Store the former value of `pc` and `sp` to `normal_pc` and `normal_sp` respectively.
. Set `cra.type` to `6` (exit), `cra.cursor` to `cra.base`.
. Write `rs1` to `switch_reg`, `rd` to `exit_reg`.
. Set `cwrld` to `1` (secure world).

*When `x[rs1].async = 1` (asynchronous):*

. Write `x[rs1]` to `switch_cap`, and `cnull` to `x[rs1]`.
. Load the content at the memory location `[switch_cap.base, switch_cap.base + CLENBYTES)` to the program counter (`pc`).
. Load the content at the memory location `[switch_cap.base + CLENBYTES, switch_cap.base + 2 * CLENBYTES)` to `ceh`.
. For `i = 1, 2, ..., 31`, load the content at the memory location
`[switch_cap.base + (i + 1) * CLENBYTES, switch_cap.base + (i + 2) * CLENBYTES)`, to `x[i]`.
. Store the former value of `pc` and `sp` to `normal_pc` and `normal_sp` respectively.
. Set `switch_cap.type` to `5` (sealed-return), `switch_cap.cursor` to `switch_cap.base`, `switch_cap.async` to `0` (synchronous).
. Write `rs1` to `switch_reg`, `rd` to `exit_reg`.
. Set `cwrld` to `1` (secure world).

.Note
****

The `rd` register will be set to a value indicating the cause of exit when
the CPU core exits from the secure world synchronously or asynchronously.

****

=== CAPEXIT

The CAPEXIT instruction causes an exit from the secure world into the normal world.
The instruction is only available in the secure world and can only be used with an exit capability.
It's roughly equivalent to the RETURN instruction.

.CAPEXIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0100011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Illegal instruction (2)
- `cwrld` is `0` (normal world).
* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not an integer.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `6` (exit).

*If no exception is raised:*

. Write `x[rs1]` to `cap` and `cnull` to `x[rs1]`.
. Set `pc.cursor` to `x[rs2]`, and write `pc`, `ceh`, and `csp`
to the memory location `[cap.base, cap.base + CLENBYTES)`,
`[cap.base + CLENBYTES, cap.base + 2 * CLENBYTES)`, and
`[cap.base + 2 * CLENBYTES, cap.base + 3 * CLENBYTES)` respectively.
. Write the content of `normal_pc` and `normal_sp` to `pc` and `sp` respectively.
. Set `cap.type` to `4` (sealed), `cap.async`
to `0` (synchronous), and write the resulting `cap` to `x[switch_reg]`.
. Set `exit_reg` to `0` (normal exit).
. Set `cwrld` to `0` (normal world).
