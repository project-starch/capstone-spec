:reproducible:

= Interrupts and Exceptions

TODO: add support for nesting

TODO: Note that it is safe to delegate exception handling but not safe to
delegate interrupt handling. Hence we need to distinguish between
exceptions and interrupts

When an interrupt or exception occurs, the behaviour of a processor core
depends on which world it is currently executing in (i.e., the content of
the `cwrld` register).
If the core is executing in the normal world, the behaviour is entirely
inherited from RISC-V.
Otherwise, if the core is executing in the secure world,

*If the content in `ceh` is a valid sealed capability and the content in `switch_cap` is a valid sealed-return capability:*

. Store the current value of the program counter (`pc`) to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the content of the `i`-th general purpose
to the memory location `[switch_cap.base + i * CLENBYTES, switch_cap.base + (i + 1) * CLENBYTES)`.
. Set the `reg` field of `switch_cap` to `0` (asynchronous),
. Store the content of `switch_cap` to the memory location
`[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. Write the content of `ceh` to the register `x[reg]` where `reg` is the original
content of the `reg` field of `switch_cap`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Scrub the other general-purpose registers.
. Set the `cwrld` register to `0` (normal world).
. Trigger exception handling in the normal world.

// Something similar to try-catch can be considered

*Otherwise:*

. Write `cnull` to the register `x[reg]` where `reg` is the original
content of the `reg` field of `switch_cap`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Scrub the other general-purpose registers.
. Set the `cwrld` register to `0` (normal world).
. Trigger the exception handling in the normal world.

.Note
****
Compare this with link:#world-switch[CAPEXIT]. We require that CAPEXIT be provided
with a valid sealed-return capability rather than use the latent capability in
`switch_cap`. This allows us to enforce containment of domains in the secure world, so
that a domain is prevented from escaping
from the secure world when such a behaviour is undesired.
****