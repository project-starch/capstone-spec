:reproducible:

= Interrupts and Exceptions

// TODO: add support for nesting

== Exception and Exit Codes

.*Note: where are the _exception codes_ relevant?*
[%collapsible]
====
****
For _{isa_var_pure}_, there is only one place where exception codes are relevant,
which is the argument to pass to the _exception handler domain_.

For _{isa_var_hybrid}_, however, there are three places where we need to consider:

. *Handleable Exception:* The argument to pass to the _exception handler domain_.
. *Unhandleable Exception:* The value returned to the CAPENTER instruction in the user process.
. *Interrupt:* The exception code that the OS sees.

The argument passed to the _exception handler domain_ will be in the register `cra` and `a0`,
and the exit code the user process receives will be in the register specified by `exit_reg`.
****
====

The _exception code_ is what the _exception handler domain_ receives as an argument
when an exception occurs on _{isa_var_pure}_ or in _{isa_var_hybrid}_ secure world.
It is an integer value that indicates what the type of the exception is.

_{isa_var_hybrid}_ also has _exit codes_, which are the values returned to the CAPENTER
instruction in case the exception cannot be handled in the secure world.

We define the exception code and the exit code for each type of exception below.
It aligns with the exception codes defined in {base_isa_name}, where applicable, for ease of
implementation and interoperability.

.Exception codes and exit codes for {isa_var_pure} and {isa_var_hybrid} secure world
[%header%autowidth.stretch]
|===
| Exception | Exception code | {isa_var_hybrid} exit code
| Instruction address misaligned | 0 | 1
| Instruction access fault | 1 | 1
| Illegal instruction | 2 | 1
| Breakpoint | 3 | 1
| Load address misaligned | 4 | 1
| Load access fault | 5 | 1
| Store/AMO address misaligned | 6 | 1
| Store/AMO access fault | 7 | 1
| Unexpected operand type | 24 | 1
| Invalid capability | 25 | 1
| Unexpected capability type | 26 | 1
| Insufficient capability permissions | 27 | 1
| Capability out of bound | 28 | 1
| Illegal operand value | 29 | 1
| Unhandleable exception | 63 | N/A in _{isa_var_hybrid}_
|===

For interrupts, the same encodings as in {base_isa_name} are used.

.*Note: _{isa_var_hybrid}_ exit code*
[%collapsible]
====
****
Currently, we use the same exit code `1` for all exception types to
protect the confidentiality of the secure world execution.
****
====

== Exception Data

For _{isa_var_pure}_ and the secure world in _{isa_var_hybrid}_, the exception-related
data is stored in the `tval` CSR, similar to {base_isa_name}. The exception handler
can use the value to decide how to handle the exception.
However, such data is available _only_ for in-domain exception handling, where the
exception handling process does not involve a domain switch.

.*Note: `tval` is only available in in-domain exception handling*
[%collapsible]
====
****
For exception handling that crosses domain (i.e., when `ceh` is a valid sealed capability)
or world boundaries (i.e., when the normal world ends up handling the exception),
the exception data (i.e., the data in `tval`) is not available.
This is to protect the confidentiality of domain execution.
Note that this design does not stop the excepted domain from selectively
trusting a different domain with such data.
****
====

For exceptions defined in {base_isa_name}, the same data as in it is written to `tval`.
For the added exceptions, the following data is written to `tval`:

// FIXME
.Exception data for {isa_var_pure} and {isa_var_hybrid} secure world
[%header%autowidth.stretch]
|===
| Exception |  Data 
| `Unexpected operand type (24)` | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| `Invalid capability (25)` | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| `Unexpected capability type (26)` | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| `Insufficient capability permissions (27)` | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| `Capability out of bound (28)` | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| `Illegal operand value (29)` | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| `Unhandleable exception (63)` | N/A
|===

== _{isa_var_pure}_

For _{isa_var_pure}_, the handling of interrupts and exceptions is relatively
straightforward. Regardless of whether the event is an interrupt or an
exception (and what the type of the interrupt or exception is), the processor
core will always transfer the control flow to the corresponding handler domain
(specified in the `ceh` register for exceptions and
the `cih` register for interrupts).

The current context is saved and sealed in a sealed-return capability which
is then supplied to the exception/interrupt handler domain as an argument.

When exception/interrupt handling is complete,
the exception/interrupt handler domain can use the RETURN instruction to resume the
execution of the excepted domain.
This process resembles that of a CALL-RETURN
pair, except that it is asynchronous, rather than synchronous,
to the execution of the original domain.

// TODO: specify what happens if any of the involved memory accesses fails

=== Interrupt Status

The `cis` CSR encodes the control and status associated with interrupts.
The diagram below shows its layout.

.`cis` CSR layout
[wavedrom,,svg]
....
{reg: [
    {bits: 1, name: 'EIP'},
    {bits: 1, name: 'EIE' },
    {bits: 1, name: 'TIP' },
    {bits: 1, name: 'TIE' },
    {bits: 1, name: 'SIP' },
    {bits: 1, name: 'SIE' },
    {bits: 10, name: 'reserved (WPRI)'}
]}
....

Each pair of `xIP` and `xIE` fields describes the status of
the interrupt type `x`. 
The interrupt type `x` is pending if the `xIP` field is set to
`1`, and enabled if the `xIE` field is set to `1`.
Currently, three types of interrupts
are supported: external interrupts (`E`), timer interrupts (`T`),
and software interrupts (`S`).
The definitions for those interrupt types match those in {base_isa_name}.

All the fields are read-write, but only when `cih` contains a capability.

.*Note: why not require a valid sealed capability?*
[%collapsible]
====
****
We can require that the fields in `cis` are read-write only when
`cih` contain a _valid sealed_ capability,
but that would be more costly than a simple check of the type of data in `cih`.
****
====

=== Interrupt Delivery

The interrupt delivery process starts with a certain event
typically asynchronous to the execution of the hardware thread.
The sources of such events include the external interrupt controller,
the timer, and other CPU cores, which correspond to the external,
timer, and software interrupt types (i.e., `x = E`, `T`, and `S`).
When such an event occurs, the `xIP` field in the `cis` register
is set to `1` to indicate that the interrupt is pending.

At any point during the execution of a hardware thread,
if any pair of `xIP` and `xIE` fields are both `1` and at the same
time the `cih` register contains
a capability, the interrupt is delivered to the interrupt handler
domain. 

.*Note: global interrupt enable/disable*
[%collapsible]
====
****
In _{isa_var_pure}_, the `cih` register acts as a global interrupt-enable
flag. If `cih` register does not contain a capability, all interrupts are
disabled globally.
****
====

=== Handling of Interrupts

*The interrupt is ignored if any of the following conditions is met:*

****
* `cih` is not a capability.
* `cih.valid = 0` (invalid).
* `cih.type != 4` (sealed capability).
****

*Otherwise:*

====
. Swap `pc` with the content at the memory location `[cih.base, cih.base + CLENBYTES)`.
. Swap `ceh` with the content at the memory location `[cih.base + CLENBYTES, cih.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, swap `x[i]` with the content at memory location
`[cih.base + (i + 1) * CLENBYTES, cih.base + (i + 2) * CLENBYTES)`.
. Set `cih.type` to `5` (sealed-return), `cih.cursor` to `cih.base`, `cih.reg` to `0`, and `cih.async` to `2` (upon interrupt).
. Write `cih` to the register `cra`, and `cnull` to the register `cih`.
. Write the exception code to the register `a0`.
====

=== Handling of Exceptions

// Having unhandleable exceptions is bad

.*Note: the stack of exception handler domains*
[%collapsible]
====
****
Allowing anyone to set `ceh` can lead to DoS (when `ceh` is set to invalid
values). Ideally, there should be a stack of exception handlers. Each
domain can only choose to push extra exception handlers onto the stack.
The bottom one will be provided by the kernel which is responsible for the liveness
of the system.

As this can be costly to implement, we limit the size of the stack to 2 for now,
with the bottom one provided by the interrupt handler domain `cih`.

Exceptions seem to be the dual of interrupts. Interrupt handling should be delegated
bottom-up, while exception handling should be delegated top-down.
****
====

*Follow the interrupt handling procedure with exception code `unhandleable exception (63)` if any of the following conditions is met:*

****
* The `ceh` register does not contain a capability.
* The capability in `ceh` is invalid (`valid = 0`).
* The capability in `ceh` is not a sealed (`type != 4`),
linear (`type != 0`), or non-linear capability (`type != 1`).
****

*Otherwise:*

*If the content in `ceh` is a valid sealed capability:*

====
. Swap `pc` with the content at the memory location `[ceh.base, ceh.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, swap `x[i]` with the content at the memory location
`[ceh.base + (i + 1) * CLENBYTES, ceh.base + (i + 2) * CLENBYTES)`.
. Set `ceh.type` to `5` (sealed-return), `ceh.cursor` to `ceh.base`, `ceh.reg` to `0`, and `ceh.async` to `1` (upon exception).
. Write `ceh` to the register `cra`, and `cnull` to the register `ceh`.
. Swap `ceh` with the content at the memory location `[cra.base + CLENBYTES, cra.base + 2 * CLENBYTES)`.
. Write the exception code to the register `a0`.
====

*If the content is `ceh` is a valid _executable_ non-linear capability or linear capability:*

====
. Write `pc` to `epc`.
. Write `ceh` to `pc`.
If `ceh.type != 1`, write `cnull` to `ceh`.
. Write the exception code to `cause`.
. Write extra exception data to `tval`.
====

*Otherwise, the CPU core enters the state of _<<panic,panic>>_.*

.*Note: sealing mechanism of in-domain exception handling*
[%collapsible]
====
****
As the exception handler is in the same domain as the code that caused the exception,
it is not necessary to seal the content of `csp` (or any other general purpose registers),
or otherwise prevent the excepted code from accessing it.
****
====

[#panic]
=== Panic

When a CPU core is unable to handle an exception, it enters a state called _panic_.

****
The actual behaviour of the CPU core in this state is implementation-defined, but must
be one of the following:

* <<reset,Reset>>.
* Enter an infinite loop.
* Scrub all general-purpose registers, and then load a capability that is not otherwise
available into `pc`, and a set of capabilities that are not otherwise available into
general-purpose registers.
****

The aim of the constraints above is to uphold the invariants of the capability model and
in turn the security guarantees of the system.

== _{isa_var_hybrid}_

_{isa_var_hybrid}_ retains the same interrupt and exception handling mechanism for
the normal world as in {base_isa_name}.
For the secure world in _{isa_var_hybrid}_,
the handling of interrupts and exceptions is more complex,
and it becomes relevant whether the event is an interrupt or an exception.

.*Note: overview of interrupt handling in the secure world*
[%collapsible]
====
****
For interrupts, in order to prevent denial-of-service attacks by the secure
world (e.g. a timer interrupt), the processor core needs to always transfer
the control back to the normal world safely.

The interrupt will be translated to one in the normal world
that occurs at the CAPENTER instruction used to enter the secure world.

Since interrupts are typically relevant only to the
management of system resources, the interrupt should be transparent to both
the secure world and the user process in the normal world.
In other words, the secure world will simply resume execution
from where it was interrupted after the interrupt is handled by the normal-world
OS.
****
====

.*Note: overview of exception handling in the secure world*
[%collapsible]
====
****
For exceptions, we want to give the secure world the chance to handle
them first.
If the secure world manages to handle the exception, the
normal world will not be involved. The end result is that the whole
exception or its handling is not even visible to the normal world.

If the secure world fails to handle an exception (i.e., when
it would end up <<panic,panicking>> in the case of _{isa_var_pure}_, such as when
`ceh` is not a valid sealed capability), however,
the normal world will take over.

The exception will *not* be translated into
an exception in the normal world, but instead indicated in the _exit code_
that the CAPENTER instruction in the user process receives.
The user process can then decide what to do based on the exit code (e.g.,
terminate the domain in the secure world).
****
====

Below we discuss the details of the handling of interrupts and exceptions
generated in the secure world.

=== Handling of Secure-World Interrupts

When an interrupt occurs in the secure world, the processor core directly
saves the full context, scrubs it, and exits to the normal world. It then
generates a corresponding interrupt in the normal world, and follows
the normal-world interrupt handling process thereafter.

*If the content in `switch_cap` is a valid sealed capability:*

====
. Store `pc` to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. Store `ceh` to the memory location
`[switch_cap.base + CLENBYTES, switch_cap.base + 2 * CLENBYTES)`, and write `cnull` to `ceh`.
. For `i = 1, 2, ..., 31`, store the content of `x[i]`
to the memory location `[switch_cap.base + (i + 1) * CLENBYTES, switch_cap.base + (i + 2) * CLENBYTES)`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
// in case that switch_reg is sp
. Set `switch_cap.async` to `2` (upon interrupt).
. Write `switch_cap` to the register `x[switch_reg]`, and `cnull` to `switch_cap`.
. Scrub the other general-purpose registers
(i.e., write `zero` to `x[i]` where `i != 2` and `i != switch_reg`).
. Set the `cwrld` register to `0` (normal world).
. Trigger an interrupt in the normal world.
====

*Otherwise:*

====
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
// in case switch_reg is sp
. Write `cnull` to `x[switch_reg]`.
. Scrub the other general-purpose registers
(i.e., write `zero` to `x[i]` where `i != 2` and `i != switch_reg`).
. Set the `cwrld` register to `0` (normal world).
. Trigger an interrupt in the normal world.
====

Note that in this case, there will be another exception in the normal world
when the user process resumes execution after the interrupt has been handled
by the OS, due to the invalid `switch_cap` value written to the CAPENTER
operand.

=== Handling of Secure-World Exceptions

When an exception occurs, the processor core first attempts to handle the
exception in the secure world, in the similar way as in _{isa_var_pure}_.
If this fails, the processor core saves the full context if it can
and exits to the normal world with a proper error code.

*If the content in `ceh` is a valid sealed capability:*

====
. Swap `pc` with the content at memory location `[ceh.base, ceh.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, swap `x[i]` with the content at the
memory location `[ceh.base + (i + 1) * CLENBYTES, ceh.base + (i + 2) * CLENBYTES)`.
. Set the `ceh.type` to `5` (sealed-return), `ceh.cursor` to `ceh.base`, and `ceh.async` to `1` (upon exception).
. Write `ceh` to the register `cra`, and `cnull` to the register `ceh`.
. Swap `ceh` with the content at the memory location `[cra.base + CLENBYTES, cra.base + 2 * CLENBYTES)`.
. Write the exception code to the register `a0`.
====

Note that this is exactly the same as the handling of exceptions in _{isa_var_pure}_.

*If the content is `ceh` is a valid _executable_ non-linear capability or linear capability:*

====
. Write `pc` to `epc`.
. Write `ceh` to `pc`.
If `ceh.type != 1`, write `cnull` to `ceh`.
. Write the exception code to `cause`.
. Write extra exception data to `tval`.
====

*Otherwise:*

*If the content in `switch_cap` is a valid sealed capability:*

====
. Store the current value of the program counter (`pc`) to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. Store `ceh` to the memory location `[switch_cap.base + CLENBYTES, switch_cap.base + 2 * CLENBYTES)`,
and write `cnull` to `ceh`.
. For `i = 1, 2, ..., 31`, store the content of `x[i]`
to the memory location `[switch_cap.base + (i + 1) * CLENBYTES, switch_cap.base + (i + 2) * CLENBYTES)`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Set `switch_cap.async` to `1` (upon exception).
. Write the content of `switch_cap` to `x[switch_reg]`, and `cnull` to `switch_cap`.
// Scrub is needed for linearity
. Scrub the other general-purpose registers
(i.e., write `zero` to `x[i]` where `i != 2` and `i != switch_reg`).
. Write the exit code to `x[exit_reg]`.
. Set the `cwrld` register to `0` (normal world).
====

// Something similar to try-catch can be considered

*Otherwise:*

====
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Write `cnull` to `x[switch_reg]`.
. Scrub the other general-purpose registers
(i.e., write `zero` to `x[i]` where `i != 2` and `i != switch_reg`).
. Write the exit code to `x[exit_reg]`.
. Set the `cwrld` register to `0` (normal world).
====

.*Note: comparison between synchronous and asynchronous exit*
[%collapsible]
====
****
Compare this with <<world-exit,CAPEXIT>>. We require that CAPEXIT be provided
with a valid sealed-return capability rather than use the latent capability in
`switch_cap`. This allows us to enforce containment of domains in the secure world, so
that a domain is prevented from escaping
from the secure world when such a behaviour is undesired.
****
====
