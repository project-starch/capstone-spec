:reproducible:

= Interrupts and Exceptions

TODO: add support for nesting

== Exception and Exit Codes

.Note
****
For {isa_var_pure}, there is only one place where exception codes are relevant,
which is the argument to pass to the exception handler domain.
For {isa_var_hybrid}, however, there are three places where we need to consider
some form of exception codes:

. (Handleable Exception) The argument to pass to the exception handler domain.
. (Unhandleable Exception) The value returned to the CAPENTER instruction in the user process.
. (Interrupt) The exception code that the OS sees.

The argument to pass to the exception handler
domain will be in the register `a1`, and the `rd` operand of CAPENTER will be the
exit code the user process receives.
****

The _exception code_ is what the exception handler domain receives as an argument
when an exception occurs on {isa_var_pure} or in {isa_var_hybrid} secure world.
It is an integer value that indicates what the type of the exception is.
{isa_var_hybrid} also has _exit codes_, which are the values returned to the CAPENTER
instruction in case the exception cannot be handled in the secure world.
We define the exception code and the exit code for each type of exception below.
It aligns with the exception codes defined in {base_isa_name}, where applicable, for ease of
implementation and interoperability.

.Exception codes and exit codes for {isa_var_pure} and {isa_var_hybrid} secure world
[%header%autowidth.stretch]
|===
| Exception | Exception code | {isa_var_hybrid} exit code
| Instruction address misaligned | 0 | 1
| Instruction access fault | 1 | 1
| Illegal instruction | 2 | 1
| Breakpoint | 3 | 1
| Load address misaligned | 4 | 1
| Load access fault | 5 | 1
| Store/AMO address misaligned | 6 | 1
| Store/AMO access fault | 7 | 1
| Unexpected operand type | 8 | 1
| Invalid capability | 9 | 1
|===

.Note
****
Currently, we use the same exit code `1` for all exception types to
protect the confidentiality of the secure world execution.
****

== {isa_var_pure}

For {isa_var_pure}, the handling of interrupts and exceptions is relatively
straightforward. Regardless of whether the event is an interrupt or an
exception, or what the type of the interrupt or exception is, the processor
core will always transfer the control flow to the corresponding handler domain
(specified in the `ceh` register for exceptions and
the `cih` register for interrupts).
The current
context is saved and sealed in a sealed-return capability which
is then supplied to the
exception handler domain as an argument. When exception handling is complete,
the exception handler domain can use the RETURN instruction to resume the
execution of the excepted domain. This process resembles that of a CALL-RETURN
pair, except that it is asynchronous, rather than synchronous,
to the execution of the original domain.

TODO: specify what "panics" means here

TODO: specify what happens if any of the involved memory accesses fails

=== Handling of Interrupts

TODO: need to specify how to record cause of the interrupt

TODO: interrupt masking

TODO: record the pending interrupts

*The interrupt is ignored if any of the following conditions is met:*

* `cih` is not a capability.
* `cih.valid = 0` (invalid).
* `cih.type != 4` (sealed capability).

*Otherwise:*

. Load the program counter `pc` from memory location `[cih.base, cih.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, load the content of `x[i]` from
memory location `[cih.base + i * CLENBYTES, cih.base + (i + 1) * CLENBYTES)`.
. Store the original program counter `pc` to the memory location
`[cih.base + CLENBYTES, cih.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the _original_ content of `x[i]`
to memory location
`[cih.base + i * CLENBYTES, cih.base + (i + 1) * CLENBYTES)`.
. Set `cih.type` to `5` (sealed-return), `cih.reg` to `0` (asynchronous), and `cih.async` to `1` (asynchronous).
. Write `cih` to the register `c1`.
. Write the exception code to the register `x10`.


=== Handling of Exceptions

// Having unhandleable exceptions is bad

*The CPU core panics if any of the following conditions is met:*

* The `ceh` register does not contain a capability.
* The capability in `ceh` is invalid (`valid = 0`).
* The capability in `ceh` is not a sealed capability (`type != 4`).

*Otherwise:*

. Load the program counter `pc` from memory location `[ceh.base, ceh.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, load the content of `x[i]` from
memory location `[ceh.base + i * CLENBYTES, ceh.base + (i + 1) * CLENBYTES)`.
. Store the original program counter `pc` to the memory location
`[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the _original_ content of `x[i]` to memory location
`[ceh.base + i * CLENBYTES, ceh.base + (i + 1) * CLENBYTES)`.
. Set `ceh.type` to `5` (sealed-return), `ceh.reg` to `0` (asynchronous), and `ceh.async` to `1` (asynchronous).
. Write the content of `ceh` to the register `c1`.
. Write the exception code to the register `x10`.

== {isa_var_hybrid}

{isa_var_hybrid} retains the same interrupt and exception handling mechanims for
the normal world as in {base_isa_name}.

For the secure world in {isa_var_hybrid},
the handling of interrupts and exceptions is more complex,
and it becomes relevant whether the event is an interrupt or an exception.

For interrupts, in order to prevent denial-of-service attacks by the secure
world, the processor core needs to transfer the control back to the normal
world safely. The interrupt will be translated to one in the normal world
that occurs at the CAPENTER instruction used to enter the secure world.
Since interrupts are typically relevant only to the
management of system resources, the interrupt should be transparent to both
the secure world and the user process.
In other words, the secure world will simply resume execution
from where it was interrupted after the interrupt is handled by the normal-world
OS.

For exceptions, we want to give the secure world the chance handle
them first. If the secure world manages to handle the exception, the
normal world will not be involved. The end result is that the whole
exception or its handling is not even visible to the normal world.
If the secure world fails to handle an exeption (i.e., when
it would end up panicking in the case of {isa_var_pure}, such as when
`ceh` is not a valid sealed capability), however,
the normal world will take over. The exception will not be translated into
an exception in the normal world, but instead indicated in the exit code
that the CAPENTER instruction in the user process receives.
The user process can then decide what to do based on the exit code (e.g.,
terminate the domain in the secure world).

Below we discuss the details of the handling of interrupts and exceptions
generated in the secure world.

=== Handling of Secure-World Interrupts

When an interrupt occurs in the secure world, the processor core directly
saves the full context, scrubs it, and exits to the normal world. It then
generates a corresponding interrupt in the normal world, and and follows
the normal-world interrupt handling process thereafter.

*If the content in `switch_reg` is a valid sealed capability:*

. Store the current value of the program counter (`pc`) to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the content of `x[i]`
to the memory location `[switch_cap.base + i * CLENBYTES, switch_cap.base + (i + 1) * CLENBYTES)`.
. Set `switch_cap.aync` to `1` (asynchronous).
. Write the content of `switch_cap` to the register `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Scrub the other general-purpose registers.
. Set the `cwrld` register to `0` (normal world).
. Trigger an interrupt in the normal world.

*Otherwise:*

. Write the content of `cnull` to `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Scrub the other general-purpose registers.
. Set the `cwrld` register to `0` (normal world).
. Trigger an interrupt in the normal world.

Note that in this case, there will be another exception in the normal world
when the user process resumes execution after the interrupt has been handled
by the OS, due to the invalid `switch_cap` value written to the CAPENTER
operand.

=== Handling of Secure-World Exceptions

When an exception occurs, the processor core first attempts to handle the
exception in the secure world, in the similar way as in {isa_var_pure}.
If this fails (`ceh` is not valid), the processor core saves
the full context if it can and exits to the normal
world with a proper error code.

*If the content in `ceh` is a valid sealed capability:*

. Load the program counter `pc` from memory location `[ceh.base, ceh.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, load the content of `x[i]` from
memory location `[ceh.base + i * CLENBYTES, ceh.base + (i + 1) * CLENBYTES)`.
. Store the original program counter `pc` to the memory location
`[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the _original_ content of `x[i]` to memory location
`[ceh.base + i * CLENBYTES, ceh.base + (i + 1) * CLENBYTES)`.
. Set the `ceh.type` to `5` (sealed-return), and `ceh.async` to `0` (asynchronous).
. Write the content of `ceh` to the register `c1`.
. Write the exception code to the register `x10`.

Note that this is exactly the same as the handling of exceptions in {isa_var_pure}.

*Otherwise:*

*If the content in `switch_reg` is a valid sealed capability:*

. Store the current value of the program counter (`pc`) to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the content of the `i`-th general purpose
to the memory location `[switch_cap.base + i * CLENBYTES, switch_cap.base + (i + 1) * CLENBYTES)`.
. Set `switch_cap.async` to `1` (asynchronous).
. Write the content of `switch_cap` to `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Write the exit code to `x[exit_reg]`.
. Set the `cwrld` register to `0` (normal world).

// Something similar to try-catch can be considered

*Otherwise:*

. Write the content of `cnull` to `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Write the exit code to `x[exit_reg]`.
. Set the `cwrld` register to `0` (normal world).


.Note
****
Compare this with link:#world-switch[CAPEXIT]. We require that CAPEXIT be provided
with a valid sealed-return capability rather than use the latent capability in
`switch_cap`. This allows us to enforce containment of domains in the secure world, so
that a domain is prevented from escaping
from the secure world when such a behaviour is undesired.
****