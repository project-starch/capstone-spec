:reproducible:

= Interrupts and Exceptions

TODO: add support for nesting

== Exception and Exit Codes

.Note
****
For {isa_var_pure}, there is only one place where exception codes are relevant,
which is the argument to pass to the exception handler domain.
For {isa_var_hybrid}, however, there are three places where we need to consider
some form of exception codes:

. (Handleable Exception) The argument to pass to the exception handler domain.
. (Unhandleable Exception) The value returned to the CAPENTER instruction in the user process.
. (Interrupt) The exception code that the OS sees.

The argument to pass to the exception handler
domain will be in the register `a1`, and the `rd` operand of CAPENTER will be the
exit code the user process receives.
****

The _exception code_ is what the exception handler domain receives as an argument
when an exception occurs on {isa_var_pure} or in {isa_var_hybrid} secure world.
It is an integer value that indicates what the type of the exception is.
{isa_var_hybrid} also has _exit codes_, which are the values returned to the CAPENTER
instruction in case the exception cannot be handled in the secure world.
We define the exception code and the exit code for each type of exception below.
It aligns with the exception codes defined in {base_isa_name}, where applicable, for ease of
implementation and interoperability.

.Exception codes and exit codes for {isa_var_pure} and {isa_var_hybrid} secure world
[%header%autowidth.stretch]
|===
| Exception | Exception code | {isa_var_hybrid} exit code
| Instruction address misaligned | 0 | 1
| Instruction access fault | 1 | 1
| Illegal instruction | 2 | 1
| Breakpoint | 3 | 1
| Load address misaligned | 4 | 1
| Load access fault | 5 | 1
| Store/AMO address misaligned | 6 | 1
| Store/AMO access fault | 7 | 1
| Unexpected operand type | 24 | 1
| Invalid capability | 25 | 1
| Unhandleable exception | 26 | N/A in {isa_var_hybrid}
|===

For interrupts, the same encodings as in {base_isa_name} are used.

.Note
****
Currently, we use the same exit code `1` for all exception types to
protect the confidentiality of the secure world execution.
****

== Exception Data

For {isa_var_pure} and the secure world in {isa_var_hybrid}, the exception-related
data is stored in the `tval` CSR, similar to {base_isa_name}. The exception handler
can use the value to decide how to handle the exception.
However, such data is available only for in-domain exception handling, where the
exception handling process does not involve a domain switch.
For exception handling
that crosses domain or world boundaries (i.e., when `ceh` is a sealed capability or
when the normal world ends up handling the exception), the exception data is not
available. This is to protect the confidentiality of domain execution.
Note that this design does not stop the excepted domain from selectively
trusting a different domain with such data.

For exceptions defined in {base_isa_name}, the same data as in it is written to `tval`.
For the added exceptions, the following data is written to `tval`:

.Exception data for {isa_var_pure} and {isa_var_hybrid} secure world
[%header%autowidth.stretch]
|===
| Exception |  Data 
| Unexpected operand type | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| Invalid capability | The instruction itself (or the lowest XLEN bits if it is wider than XLEN)
| Unhandleable exception | N/A
|===

== {isa_var_pure}

For {isa_var_pure}, the handling of interrupts and exceptions is relatively
straightforward. Regardless of whether the event is an interrupt or an
exception, or what the type of the interrupt or exception is, the processor
core will always transfer the control flow to the corresponding handler domain
(specified in the `ceh` register for exceptions and
the `cih` register for interrupts).
The current
context is saved and sealed in a sealed-return capability which
is then supplied to the
exception handler domain as an argument. When exception handling is complete,
the exception handler domain can use the RETURN instruction to resume the
execution of the excepted domain. This process resembles that of a CALL-RETURN
pair, except that it is asynchronous, rather than synchronous,
to the execution of the original domain.

TODO: specify what happens if any of the involved memory accesses fails

=== Interrupt Status

The `cis` CSR encodes the control state associated with interrupts.
The diagram below shows its layout.

.`cis` CSR layout
[wavedrom,,svg]
....
{reg: [
    {bits: 1, name: 'EIP'},
    {bits: 1, name: 'EIE' },
    {bits: 1, name: 'TIP' },
    {bits: 1, name: 'TIE' },
    {bits: 1, name: 'SIP' },
    {bits: 1, name: 'SIE' },
    {bits: 10, name: 'reserved'}
]}
....

Each pair of `xIP` and `xIE` fields describes the status of
the interrupt type `x`. 
The interrupt type `x` is pending if the `xIP` field is set to
`1`, and enabled if the `xIE` field is set to `1`.
Currently, three types of interrupts
are supported: external interrupts (`E`), timer interrupts (`T`),
and software interrupts (`S`).
The definitions for those interrupt types match those in {base_isa_name}.

All the fields are read-write, but only when
`cih` contains a capability.

.Note
****
We can require that `cih` does not contain a _valid sealed_ capability
but that would be more costly than a simple check of the
type of data in `cih`.
****

=== Interrupt Delivery

The interrupt delivery process starts with a certain event
typically asynchronous to the execution of the hardware thread.
The sources of such events include the external interrupt controller,
the timer, and other CPU cores, which correspond to the external,
timer, and software interrupt types (i.e., `x = E`, `T`, and `S`).
When such an event occurs, the `xIP` field in the `cis` register
is set to `1` to indicate that the interrupt is pending.

At any point during the execution of a hardware thread,
if any pair of `xIP` and `xIE` fields are both `1` and at the same
time the `cih` register contains
a capability, the interrupt is delivered to the interrupt handler
domain. 

.Note
****
In this way, the `cih` register acts as a global interrupt-enable
flag.
****

=== Handling of Interrupts

*The interrupt is ignored if any of the following conditions is met:*

* `cih` is not a capability.
* `cih.valid = 0` (invalid).
* `cih.type != 4` (sealed capability).

*Otherwise:*

. Load the program counter `pc` from memory location `[cih.base, cih.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, load the content of `x[i]` from
memory location `[cih.base + i * CLENBYTES, cih.base + (i + 1) * CLENBYTES)`.
. Store the original program counter `pc` to the memory location
`[cih.base + CLENBYTES, cih.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the _original_ content of `x[i]`
to memory location
`[cih.base + i * CLENBYTES, cih.base + (i + 1) * CLENBYTES)`.
. Set `cih.type` to `5` (sealed-return), `cih.reg` to `0` (asynchronous), and `cih.async` to `2` (upon interrupt).
. Write `cih` to the register `c1`.
. Write the exception code to the register `x10`.
. Write `cnull` to the register `cih`.

=== Handling of Exceptions

// Having unhandleable exceptions is bad

.Note
****
Allowing anyone to set `ceh` can lead to DoS (when `ceh` is set to invalid
values). Ideally, there should be a stack of exception handlers. Each
domain can only choose to push extra exception handlers onto the stack.
The bottom one will be provided by the kernel which is responsible for the liveness
of the system.
As this can be costly to implement, we limit the size of the stack to 2 for now,
with the bottom one provided by the interrupt handler domain `cih`.

Exceptions seem to be the dual of interrupts. Interrupt handling should be delegated
bottom-up, while exception handling should be delegated top-down.
****

*Follow the interrupt handling procedure with exception code `26` (unhandleable exception) if any of the following conditions is met:*

* The `ceh` register does not contain a capability.
* The capability in `ceh` is invalid (`valid = 0`).
* The capability in `ceh` is not a sealed (`type != 4`),
linear (`type != 0`), or non-linear capability (`type != 1`).

*Otherwise:*

*If `ceh.type = 4`:*

. Load the program counter `pc` from memory location `[ceh.base, ceh.base + CLENBYTES)`.
. Load new `ceh` from memory location `[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, load the content of `x[i]` from
memory location `[ceh.base + (i + 1) * CLENBYTES, ceh.base + (i + 2) * CLENBYTES)`.
. Store the original program counter `pc` to the memory location
`[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the _original_ content of `x[i]` to memory location
`[ceh.base + (i + 1) * CLENBYTES, ceh.base + (i + 2) * CLENBYTES)`.
. Set `ceh.type` to `5` (sealed-return), `ceh.reg` to `0` (asynchronous), and `ceh.async` to `1` (upon exception).
. Write the content of `ceh` to the register `c1`.
. Write the exception code to the register `x10`.

*If `ceh.type = 0` or `1`:*

. Write `pc` to `epc`.
. Write `ceh` to `pc`.
. If `ceh.type != 1` and `ceh.type != 6`, write `cnull` to `ceh`.
. Write the exception code to `cause`
. Write extra exception data to `tval`.

.Note
****
The `deh` register is designed to hold data that the in-domain exception handler
can utilize.
As the exception handler is in the same domain as the code that caused the exception,
it is not necessary to seal the content of `deh`, or otherwise prevent the excepted code
from accessing it.
****

=== Panic

When a CPU core is unable to handle an exception, it enters a state called _panic_.
The actual behaviour of the CPU core in this state is implementation-defined, but must
be one of the following:

* Reset.
* Enter an infinite loop.
* Scrub all general-purpose registers, and then load a capability that is not otherwise
available into `pc`, and a set of capabilities that are not otherwise available into
general-purpose registers.

The aim of the constraints above is to uphold the invariants of the capability model and
in turn the security guarantees of the system.

== {isa_var_hybrid}

{isa_var_hybrid} retains the same interrupt and exception handling mechanims for
the normal world as in {base_isa_name}.

For the secure world in {isa_var_hybrid},
the handling of interrupts and exceptions is more complex,
and it becomes relevant whether the event is an interrupt or an exception.

For interrupts, in order to prevent denial-of-service attacks by the secure
world, the processor core needs to transfer the control back to the normal
world safely. The interrupt will be translated to one in the normal world
that occurs at the CAPENTER instruction used to enter the secure world.
Since interrupts are typically relevant only to the
management of system resources, the interrupt should be transparent to both
the secure world and the user process.
In other words, the secure world will simply resume execution
from where it was interrupted after the interrupt is handled by the normal-world
OS.

For exceptions, we want to give the secure world the chance to handle
them first. If the secure world manages to handle the exception, the
normal world will not be involved. The end result is that the whole
exception or its handling is not even visible to the normal world.
If the secure world fails to handle an exeption (i.e., when
it would end up panicking in the case of {isa_var_pure}, such as when
`ceh` is not a valid sealed capability), however,
the normal world will take over. The exception will not be translated into
an exception in the normal world, but instead indicated in the exit code
that the CAPENTER instruction in the user process receives.
The user process can then decide what to do based on the exit code (e.g.,
terminate the domain in the secure world).

Below we discuss the details of the handling of interrupts and exceptions
generated in the secure world.

=== Handling of Secure-World Interrupts

When an interrupt occurs in the secure world, the processor core directly
saves the full context, scrubs it, and exits to the normal world. It then
generates a corresponding interrupt in the normal world, and and follows
the normal-world interrupt handling process thereafter.

*If the content in `switch_reg` is a valid sealed capability:*

. Store the current value of the program counter (`pc`) to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the content of `x[i]`
to the memory location `[switch_cap.base + i * CLENBYTES, switch_cap.base + (i + 1) * CLENBYTES)`.
. Set `switch_cap.aync` to `2` (upon interrupt).
. Write the content of `switch_cap` to the register `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Scrub the other general-purpose registers.
. Set the `cwrld` register to `0` (normal world).
. Trigger an interrupt in the normal world.

*Otherwise:*

. Write the content of `cnull` to `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Scrub the other general-purpose registers.
. Set the `cwrld` register to `0` (normal world).
. Trigger an interrupt in the normal world.

Note that in this case, there will be another exception in the normal world
when the user process resumes execution after the interrupt has been handled
by the OS, due to the invalid `switch_cap` value written to the CAPENTER
operand.

=== Handling of Secure-World Exceptions

When an exception occurs, the processor core first attempts to handle the
exception in the secure world, in the similar way as in {isa_var_pure}.
If this fails (`ceh` is not valid), the processor core saves
the full context if it can and exits to the normal
world with a proper error code.

*If the content in `ceh` is a valid sealed capability:*

. Load the program counter `pc` from memory location `[ceh.base, ceh.base + CLENBYTES)`.
. Load new `ceh` from memory location `[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. Load new `deh` from memory location `[ceh.base + 2 * CLENBYTES, ceh.base + 3 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, load the content of `x[i]` from
memory location `[ceh.base + (i + 2) * CLENBYTES, ceh.base + (i + 3) * CLENBYTES)`.
. Store the original program counter `pc` to the memory location
`[ceh.base + CLENBYTES, ceh.base + 2 * CLENBYTES)`.
. Store the original `deh` to the memory location `[ceh.base + 2 * CLENBYTES, ceh.base + 3 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the _original_ content of `x[i]` to memory location
`[ceh.base + (i + 2) * CLENBYTES, ceh.base + (i + 3) * CLENBYTES)`.
. Set the `ceh.type` to `5` (sealed-return), and `ceh.async` to `1` (upon exception).
. Write the content of `ceh` to the register `c1`.
. Write the exception code to the register `x10`.

Note that this is exactly the same as the handling of exceptions in {isa_var_pure}.

*If the content is `ceh` is a valid executable non-linear capability or linear capability:*

. Write `pc` to `epc`.
. Write `ceh` to `pc`.
. If `ceh.type != 1` and `ceh.type != 6`, write `cnull` to `ceh`.
. Write the exception code to `cause`
. Write extra exception data to `tval`.

*Otherwise:*

*If the content in `switch_reg` is a valid sealed capability:*

. Store the current value of the program counter (`pc`) to the memory location
`[switch_cap.base, switch_cap.base + CLENBYTES)`.
. Store `ceh` to the memory location `[switch_cap.base + CLENBYTES, switch_cap.base + 2 * CLENBYTES)`.
. Store `deh` to the memory location `[switch_cap.base + 2 * CLENBYTES, switch_cap.base + 3 * CLENBYTES)`.
. For `i = 1, 2, ..., 31`, store the content of the `i`-th general purpose
to the memory location `[switch_cap.base + (i + 2) * CLENBYTES, switch_cap.base + (i + 3) * CLENBYTES)`.
. Set `switch_cap.async` to `1` (upon exception).
. Write the content of `switch_cap` to `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Write the exit code to `x[exit_reg]`.
. Set the `cwrld` register to `0` (normal world).

// Something similar to try-catch can be considered

*Otherwise:*

. Write the content of `cnull` to `x[switch_reg]`.
. Load the program counter `pc` and the stack pointer `sp` from `normal_pc` and
`normal_sp` respectively.
. Write the exit code to `x[exit_reg]`.
. Set the `cwrld` register to `0` (normal world).


.Note
****
Compare this with link:#world-switch[CAPEXIT]. We require that CAPEXIT be provided
with a valid sealed-return capability rather than use the latent capability in
`switch_cap`. This allows us to enforce containment of domains in the secure world, so
that a domain is prevented from escaping
from the secure world when such a behaviour is undesired.
****