:reproducible:

= Capability Manipulation Instructions

{proj_name} provides instructions for creating, modifying, and destroying capabilities.
Note that due to the guarantee of provenance of capabilities, those instructions are
the _only_ way to manipulate capabilities. In particular, it is not possible to manipulate
capabilities by manipulating the content of a memory location or register using
other instructions.

== Cursor, Bounds, and Permissions Manipulation

[#cap-mov]
=== Capability Movement

Capabilities can be moved between registers with the MOVC instruction.

.MOVC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability

*If no exception is raised:*
If `rs1 = rd`, the instruction is a no-op.
Otherwise, write `x[rs1]` to `x[rd]`, and if `x[rs1]` is not a non-linear capability (i.e., `type != 1`) or
an exit capability (i.e., `type != 6`),
write `cnull` to `x[rs1]`.

[#cursor-inc]
=== Cursor Increment

The CINCOFFSET and CINCOFFSETIMM instructions increment the `cursor` of a
capability by a give amount (offset).

.CINCOFFSET instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0001101' }
]}
....

.CINCOFFSETIMM instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b011' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not an integer (for CINCOFFSET).
* Unexpected capability type (26)
- `x[rs1]` does not have `type = 0` (linear) or `type = 1` (non-linear).

*If no exception is raised:*
For CINCOFFSET, the offset is read from `x[rs2]`.
For CINCOFFSETIMM, the offset is the 12-bit sign-extended immediate field
`imm`. If the offset is `0`, the instructions are semantically equivalent to
`MOVC rd, rs1`. Otherwise, the instructions are equivalent to an atomic execution
of `MOVC rd, rs1` followed by an increment of `x[rd].cursor` by
the offset.

[#cursor-set]
=== Cursor Setter

The `cursor` field of a capability can also be directly set with the SCC instruction.

.SCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000101' }
]}
....

*An exception is raised if any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
- `x[rs1]` is not an integer.
* Unexpected capability type (26)
- `x[rd]` does not have `type = 0` (linear) or `type = 1` (non-linear).

[#field-get]
=== Field Getter

The `cursor` field of a capability can also be directly set and read with
the SCC and LCC instructions respectively.

.LCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (Z)' }
]}
....

*An exception is raised if any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Illegal operand value (29)
- The immediate value `imm` is greater than `6`.
- The immediate value `imm` is `0` and `x[rs1]` does not have `type = 0` (linear), `type = 1` (non-linear),
or `type = 3` (uninitialised).
- The immediate value `imm` is `2` and `x[rs1]` has `type = 6` (exit).
- The immediate value `imm` is `3` and `x[rs1]` has `type = 4` (sealed), `type = 5` (sealed-return), or `type = 6` (exit).
- The immediate value `imm` is `4` and `x[rs1]` has `type = 4` (sealed), `type = 5` (sealed-return), or `type = 6` (exit).
- The immediate value `imm` is `5` and `x[rs1]` does not have `type = 4` (sealed) or `type = 5` (sealed-return).
- The immediate value `imm` is `6` and `x[rs1]` does not have `type = 5` (sealed-return).

*If no exception is raised:*
Depending on the immediate value `imm`,
the instruction write different fields of `x[rs1]` to `x[rd]`
according to the following table:

[%header,%autowidth.stretch]
|===
|`imm` | Field read
|`0` | `cursor`
|`1` | `type`
|`2` | `base`
|`3` | `end`
|`4` | `perms`
|`5` | `async`
|`6` | `reg`
|===

[#shrink]
=== Bounds Shrinking

The bounds (`base` and `end` fields) of a capability can be shrunk with the SHRINK instruction.

.SHRINK instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000001' }
]}
....

The instruction attempts to set the bounds of the capability 
`x[rd]` to `[x[rs1], x[rs2])`.

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
- `x[rs1]` is not an integer.
- `x[rs2]` is not an integer.
* Illegal operand value (29)
- `x[rd].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
- `x[rs1] >= x[rs2]`.
- `x[rs1] < x[rd].base` or `x[rs2] > x[rd].end`.

[#split]
=== Bounds Splitting

The SPLIT instruction can split a capability into two by splitting the bounds.

.SPLIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000110' }
]}
....

The instruction attempts to split
the capability `x[rs1]` into two capabilities, one with bounds `[x[rs1].base, x[rs2])` and the other with bounds
`[x[rs2], x[rs1].end)`.

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is neither `0` nor `1` (neither linear nor non-linear).
* Illegal operand value (29)
- `x[rs2]` is not an integer.
- `x[rs2] \<= x[rs1].base` or `x[rs2] >= x[rs1].end`.

*If no exception is raised:* 
Set `x[rs1].end` to `x[rs2]`. A new
capability is created with `base = x[rs2]` and the other fields equal to those of the original `x[rs1]`. The new capability is written to `x[rd]`.

[#tighten]
=== Permission Tightening

The TIGHTEN instruction tightens the permissions (`perms` field) of a capability.

.TIGHTEN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000010' }
]}
....

The instruction attempts to set 
`x[rd].perms` to `x[rs1]`.

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
- `x[rs1]` is not an integer.
* Unexpected capability type (26)
- `x[rd].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* Illegal operand value (29)
- `x[rs1]` is outside the range of `perms`.
- `x[rs1] \<=p x[rd].perms` does not hold.

== Type Manipulation

Some instructions affect the `type` field of a capability. 
// In general, the `type` field
// cannot be set arbitrarily. Instead, it is changed as the side effect of certain semantically
// significant operations.

[#delin]
=== Delinearisation

The DELIN instruction delinearises a linear capability.

.DELIN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
* Unexpected capability type (26)
- `x[rd].type` is not `0` (linear).

*If no exception is raised:* `x[rd].type`
is set to `1` (non-linear).

[#init]
=== Initialisation

The INIT instruction transforms an uninitialised capability into a linear capability
after its associated memory region has been fully initialised (written with new data).

.INIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
* Unexpected capability type (26)
- `x[rd].type` is not `3` (uninitialised).
* Illegal operand value (29)
- `x[rd].cursor` and `x[rd].end` are not equal.

*If no exception is raised:* `x[rd].type`
is set to `0` (linear).

[#seal]
=== Sealing

The SEAL instruction seals a linear capability.

.SEAL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000111' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
* Unexpected capability type (26)
- `x[rd].type` is not `0` (linear).
* Insufficient capability permissions (27)
- `6 \<=p x[rd].perms` does not hold.
* Capability out of bound (28)
- The size of the memory region associated with `x[rd]` is smaller than
`CLENBYTES * 34` bytes. That is, `x[rd].end - x[rd].base < CLENBYTES * 34`.

*If no exception is raised:* `x[rd].type`
is set to `2` (sealed), and `x[rd].async` is set to `0` (synchronous).

[#drop]
== Dropping

TODO: check whether dropping is actually necessary.

The DROP instruction invalidates a capability.

.DROP instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).

*If no exception is raised:* `x[rs1].valid`
is set to `0` (invalid).

[#revocation]
== Revocation

[#revcap-creation]
=== Revocation Capability Creation

The MREV instruction creates a revocation capability.

.MREV instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `0` (linear).

*If no exception is raised:* A new capability is created in `x[rd]` with the same
`base`, `end`, `perms` and `cursor` fields as `x[rs1]`.
The `type` field of the new capability is set to `2` (revocation).

[#rev-operation]
=== Revocation Operation

The REVOKE instruction revokes a capability.

.REVOKE instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `2` (revocation).

*If no exception is raised:*

For all capabilities `c` in the system (in either a register or
memory location), `c.valid` is set to `0` (invalid)
if any of the following conditions are met:

* `c.type` is not `2` (revocation), `c.valid` is `1` (valid),
and `c` aliases with `x[rs1]`.
* `c.type` is `2` (revocation), `c.valid` is `1` (valid), and `x[rs1] <t c`.

`x[rs1].type` is set to `0` (linear)
if any of the following conditions are met for each invalidated `c`:

* The type of `c` is non-linear (i.e., `c.type != 1`)
* `2 \<=p c.perms` does not hold

Otherwise, `x[rs1].type` is set to `3` (uninitialised),
and `x[rs1].cursor` is set to `x[rs1].base`.

// REVOKE is a bit difficult to describe.
// We preferably should use a more straightforward
// way to describe REVOKE than the one in the paper.