:reproducible:

= Capability Manipulation Instructions

{proj_name} provides instructions for creating, modifying, and destroying capabilities.
Note that due to the guarantee of provenance of capabilities, those instructions are
the _only_ way to manipulate capabilities. In particular, it is not possible to manipulate
capabilities by manipulating the content of a memory location or register using
other instructions.

== Cursor, Bounds, and Permissions Manipulation

[#cap-mov]
=== Capability Movement

Capabilities can be moved between registers with the MOVC instruction.

.MOVC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability

*If no exception is raised:*
If `rs1 = rd`, the instruction is a no-op.
Otherwise, write `x[rs1]` to `x[rd]`, and if `x[rs1]` is neither a non-linear capability
(i.e., `type != 1`) nor an exit capability (i.e., `type != 6`), write `cnull` to `x[rs1]`.

[#cursor-inc]
=== Cursor Increment

The CINCOFFSET and CINCOFFSETIMM instructions increment the `cursor` of a
capability by a give amount (offset).

.CINCOFFSET instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0001100' }
]}
....

.CINCOFFSETIMM instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b010' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not an integer (for CINCOFFSET).
* Unexpected capability type (26)
- `x[rs1]` does not have `type = 0` (linear) or `type = 1` (non-linear).

*If no exception is raised:*
For CINCOFFSET, the offset is read from `x[rs2]`.
For CINCOFFSETIMM, the offset is the 12-bit sign-extended immediate field
`imm`. If the offset is `0`, the instructions are semantically equivalent to
`MOVC rd, rs1`. Otherwise, the instructions are equivalent to an atomic execution
of `MOVC rd, rs1` followed by an increment of `x[rd].cursor` by
the offset.

[#cursor-set]
=== Cursor Setter

The `cursor` field of a capability can also be directly set with the SCC instruction.

.SCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000101' }
]}
....

*An exception is raised if any of the following conditions are met:*


* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not an integer.
* Unexpected capability type (26)
- `x[rs1]` does not have `type = 0` (linear) or `type = 1` (non-linear).

*If no exception is raised:*
The instruction is equivalent to an atomic execution of `MOVC rd, rs1` followed by
setting `x[rd].cursor` to `x[rs2]`.

[#field-query]
=== Field Query

The LCC instruction is used to read a field from a capability.

.LCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b010' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'imm[4:0] (Z)' },
    {bits: 7, name: '0b0000100' }
]}
....

*An exception is raised if any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Unexpected capability type (26)
- `imm = 2` and `x[rs1]` has `type = 4` (sealed), `type = 5` (sealed-return), or `type = 6` (exit).
- `imm = 3` and `x[rs1]` has `type = 6` (exit).
- `imm = 4` and `x[rs1]` has `type = 4` (sealed), `type = 5` (sealed-return), or `type = 6` (exit).
- `imm = 5` and `x[rs1]` has `type = 4` (sealed), `type = 5` (sealed-return), or `type = 6` (exit).
- `imm = 6` and `x[rs1]` does not have `type = 4` (sealed) or `type = 5` (sealed-return).
- `imm = 7` and `x[rs1]` does not have `type = 5` (sealed-return).

*If no exception is raised:*
If `imm > 7`, the instruction writes `zero` to `x[rd]`.
Otherwise, the instruction write different fields of `x[rs1]` to `x[rd]`
according to the following table:

[%header,%autowidth.stretch]
|===
|`imm` | Content of `x[rd]` after LCC
|`0` | `x[rs1].valid`
|`1` | `x[rs1].type`
|`2` | `x[rs1].cursor`
|`3` | `x[rs1].base`
|`4` | `x[rs1].end`
|`5` | `x[rs1].perms`
|`6` | `x[rs1].async`
|`7` | `x[rs1].reg`
|===

[#shrink]
=== Bounds Shrinking

The bounds (`base` and `end` fields) of a capability can be shrunk with the SHRINK instruction.

.SHRINK instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000001' }
]}
....

The instruction attempts to set the bounds of the capability 
`x[rd]` to `[x[rs1], x[rs2])`.

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
- `x[rs1]` is not an integer.
- `x[rs2]` is not an integer.
* Illegal operand value (29)
- `x[rd].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
- `x[rs1] >= x[rs2]`.
- `x[rs1] < x[rd].base` or `x[rs2] > x[rd].end`.

*If no exception is raised:*
The instruction sets the bounds of the capability  `x[rd]` to `[x[rs1], x[rs2])`,
i.e., `x[rd].base` is set to `x[rs1]` and `x[rd].end` is set to `x[rs2]`.

[#split]
=== Bounds Splitting

The SPLIT instruction can split a capability into two by splitting the bounds.

.SPLIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000110' }
]}
....

The instruction attempts to split
the capability `x[rs1]` into two capabilities, one with bounds `[x[rs1].base, x[rs2])` and the other with bounds
`[x[rs2], x[rs1].end)`.

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is neither `0` nor `1` (neither linear nor non-linear).
* Illegal operand value (29)
- `x[rs2]` is not an integer.
- `x[rs2] \<= x[rs1].base` or `x[rs2] >= x[rs1].end`.

*If no exception is raised:* 
Set `x[rs1].end` to `x[rs2]`. A new
capability is created with `base = x[rs2]` and the other fields equal to those of the original `x[rs1]`. The new capability is written to `x[rd]`.

[#tighten]
=== Permission Tightening

The TIGHTEN instruction tightens the permissions (`perms` field) of a capability.

.TIGHTEN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'imm[4:0] (Z)' },
    {bits: 7, name: '0b0000010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Unexpected capability type (26)
- `x[rs1].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* Illegal operand value (29)
- `x[rs1] \<= 7` and `x[rs1] \<=p x[rd].perms` does not hold.

*If no exception is raised:*
The instruction is equivalent to:

. If `x[rs1] > 7`, set `x[rs1].perms` to `zero`.
Otherwise, set `x[rs1].perms` to `x[rs1]`
. `MOVC rd, rs1`

== Type Manipulation

Some instructions affect the `type` field of a capability. 
// In general, the `type` field cannot be set arbitrarily.
// Instead, it is changed as the side effect of certain semantically significant operations.

[#delin]
=== Delinearisation

The DELIN instruction delinearises a linear capability.

.DELIN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rd]` is not a capability.
* Unexpected capability type (26)
- `x[rd].type` is not `0` (linear).

*If no exception is raised:* `x[rd].type` is set to `1` (non-linear).

[#init]
=== Initialisation

The INIT instruction transforms an uninitialised capability into a linear capability
after its associated memory region has been fully initialised (written with new data).

.INIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0001001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not an integer.
* Unexpected capability type (26)
- `x[rs1].type` is not `3` (uninitialised).
* Illegal operand value (29)
- `x[rs1].cursor` and `x[rs1].end` are not equal.

*If no exception is raised:* 
The instruction is equivalent to:

. Set `x[rs1].type` to `0` (linear) and `x[rs1].cursor` is set to `x[rs2]`
. `MOVC rd, rs1`

[#seal]
=== Sealing

The SEAL instruction seals a linear capability.

.SEAL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000111' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Unexpected capability type (26)
- `x[rs1].type` is not `0` (linear).
* Insufficient capability permissions (27)
- `6 \<=p x[rs1].perms` does not hold.
* Capability out of bound (28)
- The size of the memory region associated with `x[rs1]` is smaller than
`CLENBYTES * 34` bytes. That is, `x[rs1].end - x[rs1].base < CLENBYTES * 34`.

*If no exception is raised:* 
The instruction is equivalent to:

. Set `x[rs1].type` to `2` (sealed) and `x[rs1].async` to `0` (synchronous)
. `MOVC rd, rs1`

[#drop]
== Dropping

The DROP instruction invalidates a capability.

.DROP instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).

*If no exception is raised:* `x[rs1].valid`
is set to `0` (invalid).

[#revocation]
== Revocation

[#revcap-creation]
=== Revocation Capability Creation

The MREV instruction creates a revocation capability.

.MREV instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `0` (linear).

*If no exception is raised:* A new capability is created in `x[rd]` with the same
`base`, `end`, `perms`, `cursor` and `valid` fields as `x[rs1]`.
The `type` field of the new capability is set to `2` (revocation).

[#rev-operation]
=== Revocation Operation

The REVOKE instruction revokes a capability.

.REVOKE instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `2` (revocation).

*If no exception is raised:*

For any capability `c` in the system (in either a register or
memory location), `c.valid` is set to `0` (invalid)
if any of the following conditions are met:

* `c.type` is not `2` (revocation), `c.valid` is `1` (valid),
and `c` aliases with `x[rs1]`.
* `c.type` is `2` (revocation), `c.valid` is `1` (valid), and `x[rs1] <t c`.

`x[rs1].type` is set to `0` (linear)
if, for any each invalidated capability `c`, at least one of the following
conditions are met:

* The type of `c` is non-linear (i.e., `c.type` is `1`)
* `2 \<=p c.perms` does not hold

Otherwise, `x[rs1].type` is set to `3` (uninitialised), and `x[rs1].cursor`
is set to `x[rs1].base`.
