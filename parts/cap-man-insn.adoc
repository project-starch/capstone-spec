:reproducible:

= Capability Manipulation Instructions

{proj_name} provides instructions for creating, modifying, and destroying capabilities.
Note that due to the guarantee of provenance of capabilities, those instructions are
the _only_ way to manipulate capabilities. In particular, it is not possible to manipulate
capabilities by manipulating the content of a memory location or register using
other instructions.

== Cursor, Bounds, and Permissions Manipulation

[#cap-mov]
=== Capability Movement

Capabilities can be moved between registers with the MOVC instruction.

.MOVC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability

*If no exception is raised:*
If `rs1 = rd`, the instruction is a no-op.
Otherwise, write `x[rs1]` to `x[rd]`, and if `x[rs1]` is not a non-linear capability (i.e., `type != 1`) or
an exit capability (i.e., `type != 6`),
write `cnull` to `x[rs1]`.

[#cursor-inc]
=== Cursor Increment

The CINCOFFSET and CINCOFFSETIMM instructions increment the `cursor` of a
capability by a give amount (offset).

.CINCOFFSET instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0001101' }
]}
....

.CINCOFFSETIMM instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b011' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs2]` is not an integer (for CINCOFFSET).
* `x[rs1]` does not have `type = 0` (linear) or `type = 1` (non-linear).

*If no exception is raised:*
For CINCOFFSET, the offset is read from `x[rs2]`.
For CINCOFFSETIMM, the offset is the 12-bit sign-extended immediate field
`imm`. If the offset is `0`, the instructions are semantically equivalent to
`MOVC rd, rs1`. Otherwise, the instructions are equal to an atomic execution
of `MOVC rd, rs1` followed by an increment of the `cursor` field of `rd` by
the offset.

[#cursor-set-get]
=== Cursor Setter and Getter

The `cursor` field of a capability can also be directly set and read with
the SCC and LCC instructions respectively.

.SCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000101' }
]}
....

.LCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000100' }
]}
....

*For SCC, an exception is raised if any of the following conditions are met:*

* `x[rd]` is not a capability.
* `x[rs1]` is not an integer.
* `x[rd]` does not have `type = 0` (linear) or `type = 1` (non-linear).

*For LCC, an exception is raised if any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1]` does not have `type = 0` (linear), `type = 1` (non-linear),
or `type = 3` (uninitialised).

[#shrink]
=== Bounds Shrinking

The bounds (`base` and `end` fields) of a capability can be shrunk with the SHRINK instruction.

.SHRINK instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000001' }
]}
....

The instruction attempts to set the bounds of the capability 
`x[rd]` to `[x[rs1], x[rs2])`.

*An exception is raised when any of the following conditions are met:*

* `x[rd]` is not a capability.
* `x[rd].valid` is `0` (invalid).
* `x[rd].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* `x[rs1]` is not an integer.
* `x[rs2]` is not an integer.
* `x[rs1] >= x[rs2]`.
* `x[rs1] < x[rs2].base` or `x[rs2] > x[rs1].end`.

[#split]
=== Bounds Splitting

The SPLIT instruction can split a capability into two by splitting the bounds.

.SPLIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000110' }
]}
....

The instruction attempts to split
the capability `x[rs1]` into two capabilities, one with bounds `[x[rs1].base, x[rs2])` and the other with bounds
`[x[rs2], x[rs1].end)`.

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].valid` is `0` (invalid).
* `x[rs2]` is not an integer.
* `x[rs1].type` is neither `0` nor `1` (neither linear nor non-linear).
* `x[rs2] \<= x[rs1].base` or `x[rs2] >= x[rs1].end`.

*If no exception is raised:* 
Set `x[rs1].end` to `x[rs2]`. A new
capability is created with `base = x[rs2]` and the other fields equal to those of the original `x[rs1]`. The new capability is written lo `x[rd]`.

[#tighten]
=== Permission Tightening

The TIGHTEN instruction tightens the permissions (`perms` field) of a capability.

.TIGHTEN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000010' }
]}
....

The instruction attempts to set 
`x[rd].perms` to `x[rs1]`.

*An exception is raised when any of the following conditions are met:*

* `x[rd]` is not a capability.
* `x[rd].valid` is `0` (invalid).
* `x[rd].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* `x[rs1]` is not an integer.
* `x[rs1]` is outside the range of `perms`.
* `x[rs1] <= x[rd].perms` does not hold.

== Type Manipulation

Some instructions affect the `type` field of a capability. 
// In general, the `type` field
// cannot be set arbitrarily. Instead, it is changed as the side effect of certain semantically
// significant operations.

[#delin]
=== Delinearisation

The DELIN instruction delinearises a linear capability.

.DELIN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rd]` is not a capability.
* `x[rd].valid` is `0` (invalid).
* `x[rd].type` is not `0` (linear).

*If no exception is raised:* `x[rd].type`
is set to `1` (non-linear).

[#init]
=== Initialisation

The INIT instruction transforms an uninitialised capability into a linear capability
after its associated memory region has been fully initialised (written with new data).

.INIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rd]` is not a capability.
* `x[rd].valid` is `0` (invalid).
* `x[rd].type` is not `3` (uninitialised).
* The `end` field and `x[rd].cursor` are not equal.

*If no exception is raised:* `x[rd].type`
is set to `0` (linear).

[#seal]
=== Sealing

The SEAL instruction seals a linear capability.

.SEAL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000111' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rd]` is not a capability.
* `x[rd].valid` is `0` (invalid).
* `x[rd].type` is not `0` (linear).
* `x[rd].perms` is not `3` (read-write) or `4` (read-write-execute).
* The size of the memory region associated with `x[rd]` is smaller than
`CLENBYTES * 33` bytes. That is, `x[rd].end - x[rd].base < CLENBYTES * 33`.
** The memory location `[x[rd].base, x[rd].base + CLENBYTES)` does not contain a capability.
** The `type` field of the capability at the memory location `[x[rd].base, x[rd].base + CLENBYTES)`
is neither `0` (linear) nor `1` (non-linear).
** The `perms` field of the capability at the memory location `[x[rd].base, x[rd].base + CLENBYTES)`
is neither `2` (read-execute) nor `4` (read-write-execute).
** The memory location `[x[rd].base + CLENBYTES, x[rd].base + 2 * CLENBYTES)` does not contain a capability.
** The capability at the memory location `[x[rd].base + CLENBYTES, x[rd].base + 2 * CLENBYTES)` is not `cnull`
and its `type` field is not `4` (sealed).
** The memory location `[x[rd].base + 2 * CLENBYTES, x[rd].base + 3 * CLENBYTES)` does not contain a capability.
** The `type` field of the capability at the memory location `[x[rd].base + 2 * CLENBYTES, x[rd].base + 3 * CLENBYTES)`
is neither `0` (linear) nor `1` (non-linear).

*If no exception is raised:* `x[rd].type`
is set to `2` (sealed), and `x[rd].async` is set to `0` (synchronous).

[#drop]
== Dropping

TODO: check whether dropping is actually necessary.

The DROP instruction invalidates a capability.

.DROP instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].valid` is `0` (invalid).

*If no exception is raised:* `x[rs1].valid`
is set to `0` (invalid).

[#revocation]
== Revocation

[#revcap-creation]
=== Revocation Capability Creation

The MREV instruction creates a revocation capability.

.MREV instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].type` is not `0` (linear).
* `x[rs1].valid` is `0` (invalid).

*If no exception is raised:* A new capability is created in `x[rd]` with the same
`base`, `end`, `perms` and `cursor` fields as `x[rs1]`.
The `type` field of the new capability is set to `2` (revocation).

[#rev-operation]
=== Revocation Operation

The REVOKE instruction revokes a capability.

.REVOKE instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].type` is not `2` (revocation).
* `x[rs1].valid` is `0` (invalid).

*If no exception is raised:*

For all capabilities `c` in the system (in either a register or
memory location), its `valid` field is set to `0` (invalid)
if any of the following conditions are met:

* `c.type` is not `2` (revocation), `c.valid` is `1` (valid),
and `c` aliases with `x[rs1]`
* `c.type` is `2` (revocation), `c.valid` is `1` (valid), and `x[rs1] <t c`

`x[rs1].type` is set to `0` (linear)
if any of the following conditions are met for each invalidated `c`:

* The type of `c` is non-linear (i.e., `c.type != 1`)
* The `perms` field of `c` is not `3` (read-write) or `4` (read-write-execute)

Otherwise, `x[rs1].type` is set to `3` (uninitialised),
and its `cursor` field is set to `x[rs1].base`.

// REVOKE is a bit difficult to describe.
// We preferably should use a more straightforward
// way to describe REVOKE than the one in the paper.