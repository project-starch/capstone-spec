:reproducible:

= Capability Manipulation Instructions

Capstone provides instructions for creating, modifying, and destroying capabilities.
Note that due to the guarantee of provenance of capabilities, those instructions are
the _only_ way to manipulate capabilities. In particular, it is not possible to manipulate
capabilities by manipulating the content of a memory location or register using
other instructions.

== Cursor, Bounds, and Permissions Manipulation

[#cap-mov]
=== Capability Movement

Capabilities can be moved between registers with the MOVC instruction.

.MOVC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability

*If no exception is raised:*
If `rs1` is the same register as `rd`, the instruction is a no-op.
If `rs1` is not the same register as `rd`, `rd` will contain the original content of
`rs1`, and if the content is a linear capability, `rs1` will be set to the content
of `cnull`.

[#cursor-inc]
=== Cursor Increment

The CINCOFFSET and CINCOFFSETIMM instructions increment the `cursor` of a
capability by a give amount (offset).

.CINCOFFSET instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0001101' }
]}
....

.CINCOFFSETIMM instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b011' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability
* `rs2` does not contain an integer (for CINCOFFSET)
* The capability in `rs1` has `type = 3` (uninitialised)

*If no exception is raised:*
For CINCOFFSET, the offset is read from `rs2`.
For CINCOFFSETIMM, the offset is the 12-bit sign-extended immediate field
`imm`. If the offset is `0`, the instructions are semantically equivalent to
`MOVC rd, rs1`. Otherwise, the instructions are equal to an atomic execution
of `MOVC rd, rs1` followed by an increment of the `cursor` field of `rd` by
the offset.

[#cursor-set-get]
=== Cursor Setter and Getter

The `cursor` field of a capability can also be directly set and read with
the SCC and LCC instructions respectively.

.SCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000101' }
]}
....

.LCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000100' }
]}
....

*For SCC, an exception is raised if any of the following conditions are met:*

* `rd` does not contain a capability
* `rs1` does not contain an integer
* The capability in `rd` has `type = 3` (uninitialised)

*For LCC, an exception is raised if any of the following conditions are met:*

* `rs1` does not contain a capability

[#shrink]
=== Bounds Shrinking

The bounds (`base` and `end` fields) of a capability can be shrunk with the SHRINK instruction.

.SHRINK instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000001' }
]}
....

The instruction reads `rs1` and `rs2` and attempts to set the bounds of the capability in
`rd` to `[rs1, rs2)`.

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability
* `rs1` does not contain an integer
* `rs2` does not contain an integer
* `rs1 > rs2`
* The original bounds of the capability in `rd` are `[base, end)` and
`rs1 < base` or `rs2 > end`

[#split]
=== Bounds Splitting

The SPLIT instruction can split a capability into two by splitting the bounds.

.SPLIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000110' }
]}
....

The instruction reads a capability from `rs1` and an integer from `rs2` and attempts to split
the capability into two capabilities, one with bounds `[base, rs2)` and the other with bounds
`[rs2, end)`, assuming the original bounds were `[base, end)`.

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability
* `rs2` does not contain an integer
* The `type` field of the capability in `rs1` is `3` (uninitialised)
* The original bounds of the capability in `rs1` are `[base, end)` and `rs2 < base` or `rs2 > end`

*If no exception is raised:* The capability in `rs1` has its `end` field set to `rs2`. A new
capability is created with `base = rs2` and the other fields equal to those of the original
capability in `rs1`. The new capability is written to `rd`.

[#tighten]
=== Permission Tightening

The TIGHTEN instruction tightens the permissions (`perms` field) of a capability.

.TIGHTEN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000010' }
]}
....

The instruction reads the new permissions from `rs1` and attempts to set the `perms` field
of the capability in `rd` to `rs1`.

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability
* `rs1` does not contain an integer
* The content of `rs1` is outside the range of `perms`
* The `perms` field of the capability in `rd` is `p` and `rs1 <= p` does not hold

== Type Manipulation

Some instructions affect the `type` field of a capability. 
// In general, the `type` field
// cannot be set arbitrarily. Instead, it is changed as the side effect of certain semantically
// significant operations.

[#delin]
=== Delinearisation

The DELIN instruction delinearises a linear capability.

.DELIN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability
* The `type` field of the capability in `rd` is not `0` (linear)

*If no exception is raised:* The `type` field of the capability in `rd`
is set to `1` (non-linear).

[#init]
=== Initialisation

The INIT instruction transforms an uninitialised capability into a linear capability
after its associated memory region has been fully initialised (written with new data).

.INIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability
* The `type` field of the capability in `rd` is not `3` (uninitialised)
* The `end` field and the `cursor` field of the capability in `rd` are not equal

*If no exception is raised:* The `type` field of the capability in `rd`
is set to `0` (linear).

[#seal]
=== Sealing

The SEAL instruction seals a linear capability.

.SEAL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000111' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability
* The `type` field of the capability in `rd` is not `0` (linear)

*If no exception is raised:* The `type` field of the capability in `rd`
is set to `2` (sealed).

[#drop]
== Dropping

TODO: check whether dropping is actually necessary.

== Revocation

[#revcap-creation]
=== Revocation Capability Creation

The MREV instruction creates a revocation capability.

.MREV instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability
* The `type` field of the capability in `rs1` is not `0` (linear)

*If no exception is raised:* A new capability is created in `rd` with the same
`base`, `end`, `perms`, `cursor`, and `offset` fields as the capability in `rs1`.
The `type` field of the new capability is set to `2` (revocation).

[#rev-operation]
=== Revocation Operation

The REVOKE instruction revokes a capability.

