:reproducible:

= Capability Manipulation Instructions

Capstone provides instructions for creating, modifying, and destroying capabilities.
Note that due to the guarantee of provenance of capabilities, those instructions are
the _only_ way to manipulate capabilities. In particular, it is not possible to manipulate
capabilities by manipulating the content of a memory location or register using
other instructions.

== Cursor, Bounds, and Permissions Manipulation

[#cap-mov]
=== Capability Movement

Capabilities can be moved between registers with the MOVC instruction.

.MOVC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability

*If no exception is raised:*
If `rs1` is the same register as `rd`, the instruction is a no-op.
If `rs1` is not the same register as `rd`, `rd` will contain the original content of
`rs1`, and if the content is not a non-linear capability (i.e., `type != 1`) or
an exit capability (i.e., `type != 6`),
`rs1` will be set to the content of `cnull`.

[#cursor-inc]
=== Cursor Increment

The CINCOFFSET and CINCOFFSETIMM instructions increment the `cursor` of a
capability by a give amount (offset).

.CINCOFFSET instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0001101' }
]}
....

.CINCOFFSETIMM instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b011' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* `rs2` does not contain an integer (for CINCOFFSET).
* The capability in `rs1` does not have `type = 0` (linear) or `type = 1` (non-linear).

*If no exception is raised:*
For CINCOFFSET, the offset is read from `rs2`.
For CINCOFFSETIMM, the offset is the 12-bit sign-extended immediate field
`imm`. If the offset is `0`, the instructions are semantically equivalent to
`MOVC rd, rs1`. Otherwise, the instructions are equal to an atomic execution
of `MOVC rd, rs1` followed by an increment of the `cursor` field of `rd` by
the offset.

[#cursor-set]
=== Cursor Setter

The `cursor` field of a capability can also be directly set with the SCC instruction.

.SCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000101' }
]}
....

*An exception is raised if any of the following conditions are met:*

* `rd` does not contain a capability.
* `rs1` does not contain an integer.
* The capability in `rd` does not have `type = 0` (linear) or `type = 1` (non-linear).

[#field-get]
=== Field Getter

The `cursor` field of a capability can also be directly set and read with
the SCC and LCC instructions respectively.

.LCC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0]' }
]}
....

*An exception is raised if any of the following conditions are met:*

* `rs1` does not contain a capability.
* `imm` is greater than `6`.
* `imm` is `0` and the `type` field of the capability in `rs1` is not `0` (linear), `1` (non-linear)
or `3` (uninitialised).
* `imm` is `2` and the `type` field of the capability in `rs1` is `6` (exit).
* `imm` is `3` and the `type` field of the capability in `rs1` is `4` (sealed), `5` (sealed-return) or `6` (exit).
* `imm` is `4` and the `type` field of the capability in `rs1` is `4` (sealed), `5` (sealed-return) or `6` (exit).
* `imm` is `5` and the `type` field of the capability in `rs1` is neither `4` (sealed) nor `5` (sealed-return).
* `imm` is `6` and the `type` field of the capability in `rs1` is not `5` (sealed-return).

*If no exception is raised:*
Depending on the value of `imm` (i.e., zero-extension of the immediate field `imm[11:0]`),
the instruction will read different fields of the capability in `rs1` and write the value to `rd`
according to the following table:

[%header,%autowidth.stretch]
|===
|`imm` | Field read
|`0` | `cursor`
|`1` | `type`
|`2` | `base`
|`3` | `end`
|`4` | `perms`
|`5` | `async`
|`6` | `reg`
|===

[#shrink]
=== Bounds Shrinking

The bounds (`base` and `end` fields) of a capability can be shrunk with the SHRINK instruction.

.SHRINK instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000001' }
]}
....

The instruction reads `rs1` and `rs2` and attempts to set the bounds of the capability in
`rd` to `[rs1, rs2)`.

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability.
* The `valid` field of the capability in `rd` is `0` (invalid).
* The `type` field of the capability in `rd` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* `rs1` does not contain an integer.
* `rs2` does not contain an integer.
* `rs1 >= rs2`.
* The original bounds of the capability in `rd` are `[base, end)` and
`rs1 < base` or `rs2 > end`.

[#split]
=== Bounds Splitting

The SPLIT instruction can split a capability into two by splitting the bounds.

.SPLIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0000110' }
]}
....

The instruction reads a capability from `rs1` and an integer from `rs2` and attempts to split
the capability into two capabilities, one with bounds `[base, rs2)` and the other with bounds
`[rs2, end)`, assuming the original bounds were `[base, end)`.

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `valid` field of the capability in `rs1` is `0` (invalid).
* `rs2` does not contain an integer.
* The `type` field of the capability in `rs1` is neither `0` nor `1` (neither linear nor non-linear).
* The original bounds of the capability in `rs1` are `[base, end)` and `rs2 \<= base` or `rs2 >= end`.

*If no exception is raised:* The capability in `rs1` has its `end` field set to `rs2`. A new
capability is created with `base = rs2` and the other fields equal to those of the original
capability in `rs1`. The new capability is written to `rd`.

[#tighten]
=== Permission Tightening

The TIGHTEN instruction tightens the permissions (`perms` field) of a capability.

.TIGHTEN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000010' }
]}
....

The instruction reads the new permissions from `rs1` and attempts to set the `perms` field
of the capability in `rd` to `rs1`.

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability.
* The `valid` field of the capability in `rd` is `0` (invalid).
* The `type` field of the capability in `rd` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* `rs1` does not contain an integer.
* The content of `rs1` is outside the range of `perms`.
* The `perms` field of the capability in `rd` is `p` and `rs1 <= p` does not hold.

== Type Manipulation

Some instructions affect the `type` field of a capability. 
// In general, the `type` field
// cannot be set arbitrarily. Instead, it is changed as the side effect of certain semantically
// significant operations.

[#delin]
=== Delinearisation

The DELIN instruction delinearises a linear capability.

.DELIN instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability.
* The `valid` field of the capability in `rd` is `0` (invalid).
* The `type` field of the capability in `rd` is not `0` (linear).

*If no exception is raised:* The `type` field of the capability in `rd`
is set to `1` (non-linear).

[#init]
=== Initialisation

The INIT instruction transforms an uninitialised capability into a linear capability
after its associated memory region has been fully initialised (written with new data).

.INIT instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability.
* The `valid` field of the capability in `rd` is `0` (invalid).
* The `type` field of the capability in `rd` is not `3` (uninitialised).
* The `end` field and the `cursor` field of the capability in `rd` are not equal.

*If no exception is raised:* The `type` field of the capability in `rd`
is set to `0` (linear).

[#seal]
=== Sealing

The SEAL instruction seals a linear capability.

.SEAL instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: '*' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000111' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rd` does not contain a capability.
* The `valid` field of the capability in `rd` is `0` (invalid).
* The `type` field of the capability in `rd` is not `0` (linear).
* The `perms` field of the capability in `rd` is not `3` (read-write) or `4` (read-write-execute).
* The size of the memory region associated with the capability in `rd` is smaller than
`CLENBYTES * 33` bytes. That is, `end - base < CLENBYTES * 33`.
** The memory location `[rd.base, rd.base + CLENBYTES)` does not contain a capability.
** The `type` field of the capability at the memory location `[rd.base, rd.base + CLENBYTES)`
is neither `0` (linear) nor `1` (non-linear).
** The `perms` field of the capability at the memory location `[rd.base, rd.base + CLENBYTES)`
is neither `2` (read-execute) nor `4` (read-write-execute).
** The memory location `[rd.base + CLENBYTES, rd.base + 2 * CLENBYTES)` does not contain a capability.
** The capability at the memory location `[rd.base + CLENBYTES, rd.base + 2 * CLENBYTES)` is not `cnull`
and its `type` field is not `4` (sealed).
** The memory location `[rd.base + 2 * CLENBYTES, rd.base + 3 * CLENBYTES)` does not contain a capability.
** The `type` field of the capability at the memory location `[rd.base + 2 * CLENBYTES, rd.base + 3 * CLENBYTES)`
is neither `0` (linear) nor `1` (non-linear).

*If no exception is raised:* The `type` field of the capability in `rd`
is set to `2` (sealed), and the `async` field of the capability in `rd` is set to `0` (synchronous).

[#drop]
== Dropping

TODO: check whether dropping is actually necessary.

The DROP instruction invalidates a capability.

.DROP instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `valid` field of the capability in `rs1` is `0` (invalid).

*If no exception is raised:* The `valid` field of the capability in `rs1`
is set to `0` (invalid).

[#revocation]
== Revocation

[#revcap-creation]
=== Revocation Capability Creation

The MREV instruction creates a revocation capability.

.MREV instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0001000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `type` field of the capability in `rs1` is not `0` (linear).
* The `valid` field of the capability in `rs1` is `0` (invalid).

*If no exception is raised:* A new capability is created in `rd` with the same
`base`, `end`, `perms` and `cursor` fields as the capability in `rs1`.
The `type` field of the new capability is set to `2` (revocation).

[#rev-operation]
=== Revocation Operation

The REVOKE instruction revokes a capability.

.REVOKE instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0000000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `type` field of the capability in `rs1` is not `2` (revocation).
* The `valid` field of the capability in `rs1` is `0` (invalid).

*If no exception is raised:*

For all capabilities `c` in the system (in either a register or
memory location), its `valid` field is set to `0` (invalid)
if any of the following conditions are met:

* The type field of `c` is not `2` (revocation), the `valid` field of `c` is `1` (valid),
and `c` aliases with `rs1`
* The type field of `c` is `2` (revocation), the `valid` field of `c` is `1` (valid), and `rs1 <t c`

The `type` field of the capability in `rs1` is set to `0` (linear)
if any of the following conditions are met for each invalidated `c`:

* The type of `c` is non-linear (i.e., `c.type != 1`)
* The `perms` field of `c` is not `3` (read-write) or `4` (read-write-execute)

Otherwise, the `type` field of the capability in `rs1` is set to `3` (uninitialised),
and its `cursor` field is set to `base`.

// REVOKE is a bit difficult to describe.
// We preferably should use a more straightforward
// way to describe REVOKE than the one in the paper.