:reproducible:

= Introduction


{proj_name} is a novel CPU instruction set architecture (ISA) that creates
a single unified architectural abstraction for achieving multiple security
goals, thus liberating software developers from the burden of working with
the distinct fundamental primitives exposed by numerous security extensions
that often do not interoperate easily.


== Properties to Support

The ultimate goal of {proj_name} is to provide a unified architectural
abstraction for multiple security goals.
This goal requires {proj_name} to support the following properties.

____
Exclusive access:: Software should be guaranteed exclusive access to
    certain memory regions if needed. This is in spite of the existence
    of software traditionally entitled to higher privileges such as the
    OS kernel and the hypervisor.

Revocable delegation:: Software components should be able to delegate
    authority to other components in a revocable manner. For example,
    after an untrusted library function has been granted access to a
    memory region, the caller should be able to revoke this access.

Dynamically extensible hierarchy:: The hierarchy of authority should
    be dynamically extensible, rather than predefined by the architecture
    such as hypervisor-kernel-user found in traditional platforms.
    This makes it
    possible to use the same set of abstractions for memory isolation
    and memory sharing regardless of where a software component lies in
    the hierarchy.

Safe context switching:: A mechanism that protects the confidentiality
and integrity of the execution context of software
during control flow transfers across security domain boundaries, including
asynchronous ones such as those for interrupt and exception handling,
should be provided.
____

== Major Design Elements

The {proj_name} architecture design is based on the idea of capabilities,
which are unforgeable tokens that represent authority to perform
memory accesses and control flow transfers, among other operations.
{proj_name} extends the traditional capability model with new capability
types including the following.

____
Linear capabilities:: Linear capabilities are guaranteed not to
    alias with other capabilities that both grant memory access and are
    in architecturally visible locations (i.e., their actual contents
    might affect the execution of the whole system).
    Operations on linear capabilities
    maintain this property. For example, instructions
    can only move, but not copy, linear capabilities
    between geneeral-purpose registers.
    They can hence enable safe
    exclusive access to memory regions. Capabilities that do
    not have this property are called _non-linear_ capabilities.
Revocation capabilities:: 
    Revocation capabilities cannot be used to perform memory accesses
    or control flow transfers. Instead, they convey the authority to revoke other capabilities. 
    Each revocation capability is derived from a linear
    capability and can later be used to revoke (i.e., invalidate) capabilities
    derived from it. This mechanism enables
    revocable and arbitrarily extensible chains of delegation of authority.
Uninitialised capabilities::
    Uninitialised capabilities convey write-only authority to memory.
    They can be turned into linear capabilities after the memory region has
    been "`initialised`", i.e., when the whole memory region has been
    overwritten with fresh data. Uninitialised capabilities enable
    safe initialisation of memory regions and prevent secret leakage without
    incurring extra performance overhead.
____

== {isa_name} ISA Overview

While {proj_name} does not assume any specific modern ISA, we choose to propose
a {proj_name} extension to RISC-V due to its open nature and the availability
of toolchains and simulators.

The {isa_name} ISA is an {base_isa_name} extension that makes the following
types of changes to the base architecture:

* Each general-purpose register is extended to 129 bits to accommodate 128-bit capabilities.
* Part of the machine state is extended and new instructions are added to support it.
* New instructions for manipulating capabilities are added.
* New instructions for memory accesses using capabilities are added.
* New instructions for control flow transfers using capabilities are added.
* Semantics of some existing instructions are adjusted to support capabilities.
* Semantics of interrupts and exceptions are adjusted to support capabilities.

== {proj_name} Variants

In addition to {proj_name}, which is referred to as _{isa_var_pure}_ in the {isa_name} ISA,
we propose a variant of {proj_name}, called _{isa_var_hybrid}_.

While memory accesses and control flow transfers are only possible using capabilities
in _{isa_var_pure}_, _{isa_var_hybrid}_ fuses capabilities with privilege levels and
virtual memory found in traditional architectures, which allows for a smooth transition
from existing architectures to {proj_name}.

The following types of changes are made to _{isa_var_pure}_ to obtain _{isa_var_hybrid}_:

* The physical memory is partitioned into two disjoint regions,
one exclusively for accesses through capabilities and the other exclusively for accesses
through the virtual memory.
* Software components are allowed to run in either of the two _worlds_, i.e., the _normal world_
and the _secure world_.
- The _normal world_ follows the traditional privilege levels, allows both capability-based accesses
and virtual memory accesses, and is therefore compatible with existing software.
- The _secure world_ follows the _{isa_var_pure}_ design, limits memory accesses to capability-based accesses
and provides the security guarantees of {proj_name}.
* A world switching mechanism is added to support the secure switching between the two worlds.
* Semantics of some _{isa_var_pure}_ instructions are changed to support the two worlds separately.
* Semantics of interrupts and exceptions are extended to support the two worlds separately.

.Memory Accesses in _{isa_var_hybrid}_
[%header%autowidth.stretch]
|===
| World | Memory Management Unit (MMU) | Capabilities
| Normal world | Yes | Yes
| Secure world | No | Yes
|===

== Assembly Mnemonics

Each {isa_name} instruction is given a mnemonic prefixed with `CS.`.
In contexts where it is clear we are discussing {isa_name} instructions,
we will omit the `CS.` prefix for brevity.

In assembly code, the list of operands to an instruction is supplied following the
instruction mnemonic, with the operands separated by commas, in the order of
`rd`, `rs1`, `rs2`, `imm` for any operand the instruction expects.

== Notations

When specifying the semantics of instructions, we use the following notations
to represent the type of each operand:

I:: Integer register.

C:: Capability register.

S:: Sign-extended immediate.

Z:: Zero-extended immediate.

== Bibliography

The initial motivation, design, evaluation, and analysis of {proj_name} have been discussed in the following paper:

* https://www.usenix.org/conference/usenixsecurity23/presentation/yu-jason[Capstone: A Capability-based Foundation for Trustless Secure Memory Access]
  by Jason Zhijingcheng Yu, Conrad Watt, Aditya Badole, Trevor E. Carlson, Prateek Saxena.
  In _Proceedings of the 32nd USENIX Security Symposium_.
  Anaheim, CA, USA. August 2023.
