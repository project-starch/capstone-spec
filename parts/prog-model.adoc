:reproducible:

= Programming Model

The Capstone-RISC-V ISA has extended the part of the machine state,
including both some registers and the memory, to
enable the storage and handling of capabilities.

== Capabilities

=== Width

The width of a capability is 128 bits. We represent this as
`CLEN = 128` and `CLENBYTES = 16`. Note that this does not
affect the width of a raw address, which is `XLEN = 64` bits
(i.e., `XLENBYTES = 8` bytes).

=== Fields

Each capability has the following architecturally-visible fields:

.Fields in a capability
[%header,%autowidth.stretch]
|===
|Name |Range |Description
|`valid` | `0..1` | Whether the capability is valid: `0` = invalid, `1` = valid
|`type` | `0..6` | The type of the capability:
`0` = linear, `1` = non-linear, `2` = revocation,
`3` = uninitialised, `4` = sealed, `5` = sealed-return, `6` = exit
|`cursor` | `0..2^XLEN-1` |  Not applicable when `type = 4` (sealed), `type = 5` (sealed-return), or
`type = 6` (exit).
The memory address the capability points to (to be used for the next memory access)
|`base` | `0..2^XLEN-1` | Not applicable when `type = 6` (exit). The base memory address of the memory region associated with the capability
|`end` | `0..2^XLEN-1` | Not applicable when `type = 4` (sealed), `type = 5` (sealed-return), or
`type = 6` (exit).
The end memory address of the memory region associated with the capability
|`perms` | `0..4` | Not applicable when `type = 4` (sealed), `type = 5` (sealed-return) or
`type = 6` (exit).
The permissions associated with the capability:
`0` = no access, `1` = read-only, `2` = read-execute,
`3` = read-write, `4` = read-write-execute
|`count` | `0..31` | Only applicable when `type = 4` (sealed) or `type = 5` (sealed-return).
The number of register values sealed in the region
|`reg` | `0..31` | Only applicable when `type = 5` (sealed-return).
The index of the general-purpose register to restore the capability to
|===

The range of the `perms` field has a partial order `<=` defined as follows:
....
<= = { (0, 0), (1, 1), (2, 2), (3, 3), (4, 4), (0, 1), (0, 2), (0, 3), (0, 4),
       (1, 2), (1, 3), (1, 4), (2, 4), (3, 4) }
....

We say a capability `c` aliases with a capability `d` if and only if the intersection
between `[c.base, c.end)` and `[d.base, d.end)` is non-empty.

For two revocation capabilities `c` and `d` (i.e., `c.type = d.type = 2`),
we say `c <t d` if and only if

* `c` aliases with `d`
* The creation of `c` was earlier than the creation of `d`

In addition to the above fields, an implementation also needs to maintain
sufficient metadata to test the `<t` relation.
It will be clear that for any pair of revocation capabilities that alias,
the order of their creations is well-defined.

.Note
****
The `valid` field is involved in link:#revocation[revocation],
where it might be changed due to a link:#rev-operation[revocation operation]
on a different capability.
A performant implementation, therefore, may prefer not to maintain
the `valid` field inline with the other fields.

Implementations are free to maintain additional fields to
capabilities or compress the representation of the above
fields, as long as each capability fits in `CLEN` bits.
It is not required to be able to represent capabilities with
all combinations of field values, as long as the following
conditions are satisfied:

* For load and store instructions that move a capability between
a register and memory, the value of the capability is preserved.
* The resulting capability values of any operation are not more
powerful than when the same operation is performed on a Capstone-RISC-V
implementation without compression. More specifically, if an execution
trace is valid (i.e., without exceptions) on the compressed implementation,
then it must also be valid on the uncompressed implementation.
For example, a trivial yet useless compression would be to store
nothing and always return a capability with `valid = 0` (TODO:
double-check this claim).
****

== Extension to General-Purpose Registers

The Capstone-RISC-V ISA extends each of the 32 general-purpose
registers, so it contains either a capability or a raw `XLEN`-bit
integer.
The type of data contained in a register is maintained and confusion
of the type is not allowed, except for `x0`/`c0` as discussed below.
In assembly code, the type of data expected in a register operand
is indicated by the alias used for the register, as summarised
in the following table.

[%header%autowidth.stretch]
|===
| `XLEN`-bit integer | Capability
| `x0`/`zero` | `c0`/`cnull` 
| `x1`/`ra` | `c1`/`cra`
| `x2`/`sp` | `c2`/`csp`
| `x3`/`gp` | `c3`/`cgp`
| `x4`/`tp` | `c4`/`ctp`
| `x5`/`t0` | `c5`/`ct0`
| `x6`/`t1` | `c6`/`ct1`
| `x7`/`t2` | `c7`/`ct2`
| `x8`/`s0`/`fp` | `c8`/`cs0`/`cfp`
| `x9`/`s1` | `c9`/`cs1`
| `x10`/`a0` | `c10`/`ca0`
| `x11`/`a1` | `c11`/`ca1`
| `x12`/`a2` | `c12`/`ca2`
| `x13`/`a3` | `c13`/`ca3`
| `x14`/`a4` | `c14`/`ca4`
| `x15`/`a5` | `c15`/`ca5`
| `x16`/`a6` | `c16`/`ca6`
| `x17`/`a7` | `c17`/`ca7`
| `x18`/`s2` | `c18`/`cs2`
| `x19`/`s3` | `c19`/`cs3`
| `x20`/`s4` | `c20`/`cs4`
| `x21`/`s5` | `c21`/`cs5`
| `x22`/`s6` | `c22`/`cs6`
| `x23`/`s7` | `c23`/`cs7`
| `x24`/`s8` | `c24`/`cs8`
| `x25`/`s9` | `c25`/`cs9`
| `x26`/`s10` | `c26`/`cs10`
| `x27`/`s11` | `c27`/`cs11`
| `x28`/`t3` | `c28`/`ct3`
| `x29`/`t4` | `c29`/`ct4`
| `x30`/`t5` | `c30`/`ct5`
| `x31`/`t6` | `c31`/`ct6`
|===

`x0`/`c0` is a read-only register that can be used both as an
integer and as a capability, depending on the context. When used
as an integer, it has the value `0`.
When used as a capability, it has the value
`{ valid = 0, type = 0, cursor = 0, base = 0, end = 0, perms = 0 }`.
Any attempt to write to `x0`/`c0` will be silently ignored (no
exceptions are raised).

== Extension to Other Registers

=== Program Counter

* _Pure Capstone_: The program counter (`pc`) is extended to contain a capability.
* _TransCapstone_: Similar to the general-purpose registers,
the program counter (`pc`) is also extended to contain a capability or an integer.

When `pc` contains a capability, some of the fields of the capability
are checked before each instruction fetch.
An exception is raised when any of the following conditions are met:

* The `valid` field of the capability in `pc` is `0` (invalid).
* The bound of the capability in `pc` is `[base, end)`, where `base`
and `end` are the `base` and `end` fields of the capability in `pc`,
and the `cursor` field of the capability in `pc` is not in the range
`[base, end-4]` (i.e., `cursor < base` or `cursor > end-4`).

If no exception is raised, the instruction pointed to by the `cursor`
field of the capability in `pc` is fetched and executed. The `cursor`
field of the capability in `pc` is then incremented by `4` (i.e.,
`cursor += 4`).

== Added Registers

The Capstone-RISC-V ISA adds the following registers:


.Additional Registers in Capstone-RISC-V ISA
[cols="1,3a"]
|===
|*Capstone Variant*   | *Additional Registers*
|_Pure Capstone_|
[cols="1,4"]
!===
! `ceh`  ! The sealed capability for the exception handler
!===

|_TransCapstone_|
[cols="1,4"]
!===
! `ceh`  ! The sealed capability for the exception handler
! `cwrld`! The currently executed world. `0` = normal world, `1` = secure world
! `normal_pc`! The program counter for the normal world before the secure world is entered
! `normal_sp`! The stack pointer for the normal world before the secure world is entered
! `switch_reg`! The index of the general-purpose register used when switching worlds
! `switch_cap`! The capability used to store contexts when switching worlds
!===
|===

TODO: talk about how to read/write those registers.

== Extension to Memory

The memory is addressed using an `XLEN`-bit integer at byte-level
granularity.
In addition to raw integers, each `CLEN`-bit aligned address can
also store a capability.
The type of data contained in a memory location is maintained and
confusion of the type is not allowed.

== Instruction Set

The Capstone-RISC-V instruction set is based on the RV64G instruction set.
The (uncompressed) instructions are fixed 32-bit wide, and laid out in memory
in little-endian order. In the encoding space of the RV64G instruction set,
Capstone-RISC-V instructions occupies the "custom-2" subset, i.e., the opcode
of all Capstone-RISC-V instructions is `0b1011011`.

Capstone-RISC-V instruction encodings follow two basic formats: R-type and I-type,
as described below (more details are also provided in the _RISC-V ISA Manual_).

.R-type instruction format
include::r-type-format.adoc[]

.I-type instruction format
include::i-type-format.adoc[]

R-type instructions receive up to three register operands, and I-type instructions
receive up to two register operands and a 12-bit-wide immediate operand.
