:reproducible:

= Memory Access Instructions

{proj_name} provides instructions to load from and store to memory regions using capabilities.

== Load/Store with Capabilities

{proj_name} offers a set of instructions for loading and storing integers of various sizes
using capabilities.

[#load-with-cap]
=== Load

The LDD, LDW, LDH, LDB instructions load an integer in the size of doubleword, word, 
halfword, and byte respectively.
In {proj_name}, a doubleword is defined as `XLENBYTES` bytes, a word, halfword, and byte 
are defined as `XLENBYTES/2`, `XLENBYTES/4`, and `XLENBYTES/8` bytes respectively.

.LDD instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010010' }
]}
....

.LDW instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010100' }
]}
....

.LDH instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010110' }
]}
....

.LDB instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0011000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].type` is neither `0` (linear) nor `1` (non-linear).
* `x[rs1].valid` is `0` (invalid).
* `x[rs1].perms` is `0` (no access).
* `x[rs1].cursor` is
not in the range `[x[rs1].base, x[rs1].end-size]` (i.e., `x[rs1].cursor < x[rs1].base` or `x[rs1].cursor > x[rs1].end-size`), where `size`
is the size (in bytes) of the integer being loaded.
* `x[rs1].cursor` is not aligned to the size of the integer being loaded.

*If no exception is raised:* Load the content at the memory location `[x[rs1].cursor, x[rs1].cursor + size)` as an integer,
where `size` is the size of the integer
(i.e., `XLENBYTES`, `XLENBYTES/2`, `XLENBYTES/4`, or `XLENBYTES/8` bytes for LDD, LDW, LDH, and LDB respectively), to `x[rd]`.

[#store-with-cap]
=== Store

The STD, STW, STH, STB instructions store an integer in the size of doubleword, word, halfword, and byte respectively.

.STD instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0010011' }
]}
....

.STW instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0010101' }
]}
....

.STH instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0010111' }
]}
....

.STB instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0011001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialized).
* `x[rs1].valid` is `0` (invalid).
* `x[rs1].perms` is not `3` or `4` (read-write or read-write-execute).
* `x[rs1].cursor` is
not in the range `[x[rs1].base, x[rs1].end-size]` (i.e., `x[rs1].cursor < x[rs1].base` or `x[rs1].cursor > x[rs1].end-size`), where `size`
is the size (in bytes) of the integer being stored.
* `x[rs1].cursor` is not aligned to the size of the scalar value being loaded.
* `x[rs2]` is not an integer.

*If no exception is raised:* Store the integer in `x[rs2]` to the memory location `[x[rs1].cursor, x[rs1].cursor + size)`,
where `size` is the size of the integer
(i.e., `XLENBYTES`, `XLENBYTES/2`, `XLENBYTES/4`, or `XLENBYTES/8` bytes for STD, STW, STH, and STB respectively).
`x[rs1].cursor` is set to `x[rs1].cursor + size`. The data contained in the `CLEN`-bit aligned
memory location `[cbase, cend)`, which alias with memory location `[cursor, cursor + size)`
(i.e., `cbase = cursor & ~(CLENBYTES - 1)` and `cend = cbase + CLENBYTES`), will be interpreted as an integer type.

== Load/Store Capabilities

In {proj_name}, two specific instructions (i.e., LDC and LTC) are used to load and store capabilities.

[#load-cap]
=== Load Capabilities

The LDC instruction loads a capability from memory.

.LDC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].type` is neither `0` (linear) nor `1` (non-linear).
* `x[rs1].valid` is `0` (invalid).
* `x[rs1].perms` is `0` (no access).
* `x[rs1].cursor` is
not in the range `[x[rs1].base, x[rs1].end-CLENBYTES]` (i.e., `x[rs1].cursor < x[rs1].base` or `x[rs1].cursor > x[rs1].end-CLENBYTES`).
* `x[rs1].cursor` is not aligned to `CLEN` bits.
* The data contained in the memory location `[x[rs1].cursor, x[rs1].cursor + CLENBYTES)` is not a capability.
* The capability being loaded is not a non-linear capability (i.e., `type != 1`), and `x[rs1].perms`
is not `3` or `4` (read-write or read-write-execute).

*If no exception is raised:* Load the capability at the memory location `[x[rs1].cursor, x[rs1].cursor + CLENBYTES)` into `x[rd]`. If the capability being loaded is not a non-linear
capability (i.e., `type != 1`), the data contained in the memory location `[x[rs1].cursor, x[rs1].cursor + CLENBYTES)` will be
set to the content of `cnull`.

[#store-cap]
=== Store Capabilities

The STC instruction stores a capability to memory.

.STC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (C)' },
    {bits: 7, name: '0b0010001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not a capability.
* `x[rs1].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialized).
* `x[rs1].valid` is `0` (invalid).
* `x[rs1].perms` is not `3` or `4` (read-write or read-write-execute).
* `x[rs1].cursor` is
not in the range `[x[rs1].base, x[rs1].end-CLENBYTES]` (i.e., `x[rs1].cursor < x[rs1].base` or `x[rs1].cursor > x[rs1].end-CLENBYTES`).
* `x[rs1].cursor` is not aligned to `CLEN` bits.
* `x[rs2]` is not a capability.

*If no exception is raised:*
Store `x[rs2]` to the memory location `[x[rs1].cursor, x[rs1].cursor + CLENBYTES)`. `x[rs1].cursor`
is set to `x[rs1].cursor + CLENBYTES`. If `x[rs2]` is not a non-linear capability (i.e., `type != 1`),
`x[rs2]` will be set to the content of `cnull`.

== _{isa_var_hybrid}_ Added Instructions

In _{isa_var_hybrid}_, besides the LDC and STC instructions, two additional instructions (i.e., LDCR and STCR)
are added to load and store capabilities from/to the normal memory using raw addresses. These 2 instructions
are only available in _{isa_var_hybrid}_ and an exception will be raised if they are executed in _{isa_var_pure}_.

[#load-cap-raw]
=== Load with Raw Addresses

The LDCR instruction loads a capability from the normal memory using raw addresses.

.LDCR instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0011010' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not an integer.
* `x[rs1]` is not aligned to `CLEN` bits.
* `x[rs1]` is in the range `[SBASE, SEND)` (i.e., `SBASE \<= x[rs1] < SEND`).
* The data contained in the memory location `[x[rs1], x[rs1] + CLENBYTES)` is not a capability.

*If no exception is raised:* Load the capability at the memory location `[x[rs1], x[rs1] + CLENBYTES)` into `rd`.
If the capability being loaded is a non-linear capability (i.e. `type != 1`), the data contained in the
memory location `[x[rs1], x[rs1] + CLENBYTES)` will be set to the content of `cnull`.

[#store-cap-raw]
=== Store with Raw Addresses

The STCR instruction stores a capability to the normal memory using raw addresses.

.STCR instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (C)' },
    {bits: 7, name: '0b0011011' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `x[rs1]` is not an integer.
* `x[rs1]` is not aligned to `CLEN` bits.
* `x[rs1]` is in the range `[SBASE, SEND)` (i.e., `SBASE \<= x[rs1] < SEND`).
* `x[rs2]` is not a capability.

*If no exception is raised:*
Store `x[rs2]` to the memory location `[x[rs1], x[rs1] + CLENBYTES)`.
If `x[rs2]` is not a non-linear capability (i.e., `type != 1`), `x[rs2]` will be set to the
content of `cnull`.

