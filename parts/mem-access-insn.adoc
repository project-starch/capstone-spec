:reproducible:

[#load-store-cap]
= Memory Access Instructions

{proj_name} provides instructions to load and store capabilities from/to memory regions.

== _{isa_var_pure}_

In _{isa_var_pure}_, two specific instructions (i.e., LDC and LTC) are used to load and store capabilities.

=== Load Capabilities

The LDC instruction loads a capability from memory.

.LDC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b011' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is neither `0` (linear) nor `1` (non-linear).
* Insufficient capability permissions (27)
- `4 \<=p x[rs1].perms` does not hold.
* Capability out of bound (28)
- `x[rs1].cursor + imm` is not in the range `[x[rs1].base, x[rs1].end - CLENBYTES]`.
* Load address misaligned (4)
- `x[rs1].cursor + imm` is not aligned to `CLEN` bits.
* Unexpected operand type (24) (TODO)
- The data contained in the memory location `[x[rs1].cursor + imm, x[rs1].cursor + imm + CLENBYTES)` is not a capability.
* Insufficient capability permissions (27)
- The `type` field of the capability being loaded is neither `1` (non-linear) nor `6` (exit),
and `x[rs1].perms` is neither `6` (read-write) or `7` (read-write-execute).

*If no exception is raised:*
Load the capability at the memory location `[x[rs1].cursor + imm, x[rs1].cursor + imm + CLENBYTES)` into `x[rd]`.
If the capability being loaded is not a non-linear capability (i.e., `type != 1`) or an exit
capability (i.e., `type != 6`), the data contained in the memory location
`[x[rs1].cursor + imm, x[rs1].cursor + imm + CLENBYTES)` will be set to `cnull`.

=== Store Capabilities

The STC instruction stores a capability to memory.

.STC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'imm[4:0] (S)' },
    {bits: 3, name: '0b110' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (C)' },
    {bits: 7, name: 'imm[11:5] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not a capability.
- `x[rs2]` is not a capability.
* Invalid capability (25)
- `x[rs1].valid` is `0` (invalid).
* Unexpected capability type (26)
- `x[rs1].type` is not `0`, `1`, or `3` (linear, non-linear, or uninitialised).
* Illegal operand value (29)
- `x[rs1].type` is `3` (uninitialised) and `imm` is not `0`.
* Insufficient capability permissions (27)
- `x[rs1].perms` is neither `6` (read-write) nor `7` (read-write-execute).
* Capability out of bound (28)
- `x[rs1].cursor + imm` is not in the range `[x[rs1].base, x[rs1].end - CLENBYTES]`.
* Store/AMO address misaligned (6)
- `x[rs1].cursor + imm` is not aligned to `CLEN` bits.


*If no exception is raised:*
Store `x[rs2]` to the memory location `[x[rs1].cursor + imm, x[rs1].cursor + imm + CLENBYTES)`.
If `x[rs1]` is an uninitialised capability (i.e., `x[rs1].type` is `3`), 
`x[rs1].cursor` is set to `x[rs1].cursor + CLENBYTES`.
If `x[rs2]` is not a non-linear capability (i.e., `type != 1`) or an exit capability (i.e., `type != 6`),
`x[rs2]` will be set to `cnull`.

== _{isa_var_hybrid}_

In _{isa_var_hybrid}_, the LDC and STC instructions are extended to support loading and storing capabilities
from/to the normal memory using raw addresses.

* In the secure world (i.e., `cwrld` is `1`), the LDC and STC instructions remain the same as in _{isa_var_pure}_.
* In the normal world (i.e., `cwrld` is `0`), the LDC and STC instructions behave differently in different _encoding modes_.
When `emode` is `1` (capability encoding mode), the LDC and STC instructions behave the same as in _{isa_var_pure}_.
When `emode` is `0` (integer encoding mode), the LDC and STC instructions are used to load and store capabilities
from/to the normal memory using raw addresses.

=== Load Capabilities in integer encoding mode

When `cwrld` is `0` (normal world) and `emode` is `0` (integer encoding mode),
the LDC instruction loads a capability from the normal memory using raw addresses.

.LDC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (c)' },
    {bits: 3, name: '0b011' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 12, name: 'imm[11:0] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not an integer.
* Load address misaligned (4)
- `x[rs1] + imm` is not aligned to `CLEN` bits.
* Load access fault (5)
- `x[rs1] + imm` is in the range `[SBASE, SEND)`.
* Unexpected operand type (24)
- The data contained in the memory location `[x[rs1] + imm, x[rs1] + imm + CLENBYTES)` is not a capability.

*If no exception is raised:*
Load the capability at the memory location `[x[rs1] + imm, x[rs1] + imm + CLENBYTES)` into `x[rd]`.
If the `type` field of the capability being loaded is neither `1` (non-linear) nor `6` (exit),
the data contained in the memory location `[x[rs1] + imm, x[rs1] + imm + CLENBYTES)` will be set to `cnull`.

=== Store Capabilities in integer encoding mode

When `cwrld` is `0` (normal world) and `emode` is `0` (integer encoding mode),
the STC instruction stores a capability to the normal memory using raw addresses.

.STC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'imm[4:0] (S)' },
    {bits: 3, name: '0b110' },
    {bits: 5, name: 'rs1 (I)' },
    {bits: 5, name: 'rs2 (C)' },
    {bits: 7, name: 'imm[11:5] (S)' }
]}
....

*An exception is raised when any of the following conditions are met:*

* Unexpected operand type (24)
- `x[rs1]` is not an integer.
- `x[rs2]` is not a capability.
* Store/AMO address misaligned (6)
- `x[rs1] + imm` is not aligned to `CLEN` bits.
* Store/AMO access fault (7)
- `x[rs1] + imm` is in the range `[SBASE, SEND)`.

*If no exception is raised:*
Store `x[rs2]` to the memory location `[x[rs1] + imm, x[rs1] + imm + CLENBYTES)`.
If the `type` field of the capability being stored is neither `1` (non-linear) nor `6` (exit),
`x[rs2]` will be set to `cnull`.
