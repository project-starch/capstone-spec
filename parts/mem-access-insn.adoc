:reproducible:

= Memory Access Instructions

Capstone provides instructions to load from and store to memory regions using capabilities.

[#load-store-with-cap]
== Load/Store with Capabilities

Capstone offers a set of instructions for loading and storing integers of various sizes
using capabilities.

*Load:*

The LDD, LDW, LDH, LDB instructions load an integer in the size of doubleword, word, 
halfword, and byte respectively.
In Capstone, a doubleword is defined as `XLENBYTES` bytes, a word, halfword, and byte 
are defined as `XLENBYTES/2`, `XLENBYTES/4`, and `XLENBYTES/8` bytes respectively.

.LDD instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010010' }
]}
....

.LDW instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010100' }
]}
....

.LDH instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010110' }
]}
....

.LDB instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (I)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0011000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `type` field of the capability in `rs1` is neither `0` (linear) nor `1` (non-linear).
* The `valid` field of the capability in `rs1` is `0` (invalid).
* The `perms` field of the capability in `rs1` is `0` (no access).
* The bound of the capability in `rs1` is `[base, end)`, where `base` and `end` are the `base`
and `end` fields of the capability in `rs1`, and the `cursor` field of the capability in `rs1` is
not in the range `[base, end-size)` (i.e., `cursor < base` or `cursor >= end-size`), where `size`
is the size (in bytes) of the integer being loaded.
* The `cursor` field of the capability in `rs1` is not aligned to the size of the integer being loaded.

*If no exception is raised:* Load the content at the memory location `[cursor, cursor + size)` as an integer,
where `cursor` is the `cursor` field of the capability in `rs1` and `size` is the size of the integer
(i.e., `XLENBYTES`, `XLENBYTES/2`, `XLENBYTES/4`, or `XLENBYTES/8` bytes for LDD, LDW, LDH, and LDB respectively), to `rd`.

*Store:*

The STD, STW, STH, STB instructions store an integer in the size of doubleword, word, halfword, and byte respectively.

.STD instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0010011' }
]}
....

.STW instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0010101' }
]}
....

.STH instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0010111' }
]}
....

.STB instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (I)' },
    {bits: 7, name: '0b0011001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `type` field of the capability in `rs1` is not `0`, `1`, or `3` (linear, non-linear, or uninitialized).
* The `valid` field of the capability in `rs1` is `0` (invalid).
* The `perms` field of the capability in `rs1` is not `3` or `4` (read-write or read-write-execute).
* The bound of the capability in `rs1` is `[base, end)`, where `base` and `end` are the `base`
and `end` fields of the capability in `rs1`, and the `cursor` field of the capability in `rs1` is
not in the range `[base, end-size)` (i.e., `cursor < base` or `cursor >= end-size`), where `size`
is the size (in bytes) of the integer being loaded.
* The `cursor` field of the capability in `rs1` is not aligned to the size of the scalar value being loaded.
* `rs2` does not contain an integer.

*If no exception is raised:* Store the integer in `rs2` to the memory location `[cursor, cursor + size)`,
where `cursor` is the `cursor` field of the capability in `rs1` and `size` is the size of the integer
(i.e., `XLENBYTES`, `XLENBYTES/2`, `XLENBYTES/4`, or `XLENBYTES/8` bytes for STD, STW, STH, and STB respectively).
The `cursor` field of the capability in `rs1` is set to `cursor + size`. The data contained in the `CLEN`-bit aligned
memory location `[cbase, cend)`, which alias with memory location `[cursor, cursor + size)`
(i.e., `cbase = cursor & ~(CLENBYTES - 1)` and `cend = cbase + CLENBYTES`), will be interpreted as an integer type.

[#load-store-cap]
== Load/Store Capabilities

In Capstone, two specific instructions (i.e., LDC and LTC) are used to load and store capabilities.

*LDC:*

The LDC instruction loads a capability from memory.

.LDC instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: 'rd (C)' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: '*' },
    {bits: 7, name: '0b0010000' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `type` field of the capability in `rs1` is neither `0` (linear) nor `1` (non-linear).
* The `valid` field of the capability in `rs1` is `0` (invalid).
* The `perms` field of the capability in `rs1` is `0` (no access).
* The bound of the capability in `rs1` is `[base, end)`, where `base` and `end` are the `base`
and `end` fields of the capability in `rs1`, and the `cursor` field of the capability in `rs1` is
not in the range `[base, end-CLENBYTES)` (i.e., `cursor < base` or `cursor >= end-CLENBYTES`).
* The `cursor` field of the capability in `rs1` is not aligned to `CLEN` bits.
* The data contained in the memory location `[cursor, cursor + CLENBYTES)`, where `cursor` is the `cursor`
field of the capability in `rs1`, is not a capability.
* The capability being loaded is not a non-linear capability (i.e., `type != 1`), and the `perms` field of
the capability in `rs1` is not `3` or `4` (read-write or read-write-execute).

*If no exception is raised:* Load the capability at the memory location `[cursor, cursor + CLENBYTES)`, where `cursor`
is the `cursor` field of the capability in `rs1`, into `rd`. If the capability being loaded is a linear capability,
the data contained in the memory location `[cursor, cursor + CLENBYTES)` will be set to the content of `cnull`.

*STC:*

The STC instruction stores a capability to memory.

.STD instruction format
[wavedrom,,svg]
....
{reg: [
    {bits: 7, name: '0b1011011'},
    {bits: 5, name: '*' },
    {bits: 3, name: '0b001' },
    {bits: 5, name: 'rs1 (C)' },
    {bits: 5, name: 'rs2 (C)' },
    {bits: 7, name: '0b0010001' }
]}
....

*An exception is raised when any of the following conditions are met:*

* `rs1` does not contain a capability.
* The `type` field of the capability in `rs1` is not `0`, `1`, or `3` (linear, non-linear, or uninitialized).
* The `valid` field of the capability in `rs1` is `0` (invalid).
* The `perms` field of the capability in `rs1` is not `3` or `4` (read-write or read-write-execute).
* The bound of the capability in `rs1` is `[base, end)`, where `base` and `end` are the `base`
and `end` fields of the capability in `rs1`, and the `cursor` field of the capability in `rs1` is
not in the range `[base, end-CLENBYTES)` (i.e., `cursor < base` or `cursor >= end-CLENBYTES`).
* The `cursor` field of the capability in `rs1` is not aligned to `CLEN` bits.
* `rs2` does not contain a capability.

*If no exception is raised:* Store the capability in `rs2` to the memory location `[cursor, cursor + CLENBYTES)`,
where `cursor` is the `cursor` field of the capability in `rs1`. The `cursor` field of the capability in `rs1`
is set to `cursor + CLENBYTES`.
